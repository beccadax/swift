<ImportDecl>// RUN: rm -rf %t
// RUN: %swift-syntax-test -input-source-filename %s -parse-gen > %t
// RUN: diff -u %s %t
// RUN: %swift-syntax-test -input-source-filename %s -parse-gen -print-node-kind > %t.withkinds
// RUN: diff -u %S/Outputs/round_trip_parse_gen.swift.withkinds %t.withkinds
// RUN: %swift-syntax-test -input-source-filename %s -eof > %t
// RUN: diff -u %s %t
// RUN: %swift-syntax-test -serialize-raw-tree -input-source-filename %s > %t.dump
// RUN: %swift-syntax-test -deserialize-raw-tree -input-source-filename %t.dump -output-filename %t
// RUN: diff -u %s %t

import <AccessPathComponent>ABC</AccessPathComponent></ImportDecl><ImportDecl>
import <AccessPathComponent>A.</AccessPathComponent><AccessPathComponent>B.</AccessPathComponent><AccessPathComponent>C</AccessPathComponent></ImportDecl><ImportDecl><Attribute>
@objc </Attribute>import <AccessPathComponent>A.</AccessPathComponent><AccessPathComponent>B</AccessPathComponent></ImportDecl><ImportDecl><Attribute>
@objc </Attribute>import typealias <AccessPathComponent>A.</AccessPathComponent><AccessPathComponent>B</AccessPathComponent></ImportDecl><ImportDecl>
import struct <AccessPathComponent>A.</AccessPathComponent><AccessPathComponent>B</AccessPathComponent></ImportDecl><PoundWarningDecl>

#warning(<StringLiteralExpr>"<StringSegment>test warning</StringSegment>"</StringLiteralExpr>)</PoundWarningDecl><PoundErrorDecl>
#error(<StringLiteralExpr>"<StringSegment>test error</StringSegment>"</StringLiteralExpr>)</PoundErrorDecl><IfConfigDecl><IfConfigClause>

#if <IdentifierExpr><DeclNameRef>Blah</DeclNameRef></IdentifierExpr><ClassDecl>
class C <MemberDeclBlock>{<MemberDeclListItem><FunctionDecl>
  func bar<FunctionSignature><ParameterClause>(<FunctionParameter>_ a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>
  func bar1<FunctionSignature><ParameterClause>(<FunctionParameter>_ a: <SimpleTypeIdentifier><DeclNameRef>Float</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Float </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <SequenceExpr><PrefixOperatorExpr>-<FloatLiteralExpr>0.6 </FloatLiteralExpr></PrefixOperatorExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><FloatLiteralExpr>0.1 </FloatLiteralExpr><BinaryOperatorExpr>- </BinaryOperatorExpr><FloatLiteralExpr>0.3 </FloatLiteralExpr></SequenceExpr></ReturnStmt>}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>
  func bar2<FunctionSignature><ParameterClause>(<FunctionParameter>a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>b: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>c:<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>1 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>
  func bar3<FunctionSignature><ParameterClause>(<FunctionParameter>a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>1 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>
  func bar4<FunctionSignature><ParameterClause>(<FunctionParameter>_ a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>1 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>
  func foo<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<VariableDecl>
    var <PatternBinding><IdentifierPattern>a </IdentifierPattern><InitializerClause>= <StringLiteralExpr>/*comment*/"<StringSegment>ab</StringSegment><ExpressionSegment>\(<TupleExprElement><IdentifierExpr><DeclNameRef>x</DeclNameRef></IdentifierExpr></TupleExprElement>)</ExpressionSegment><StringSegment>c</StringSegment>"</StringLiteralExpr></InitializerClause></PatternBinding></VariableDecl><VariableDecl>/*comment*/
    var <PatternBinding><IdentifierPattern>b </IdentifierPattern><InitializerClause>= <PrefixOperatorExpr>/*comment*/+<IntegerLiteralExpr>2</IntegerLiteralExpr></PrefixOperatorExpr></InitializerClause></PatternBinding></VariableDecl><FunctionCallExpr><IdentifierExpr><DeclNameRef>/*comment*/
    bar</DeclNameRef></IdentifierExpr>(<TupleExprElement><IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
    bar</DeclNameRef></IdentifierExpr>(<TupleExprElement><PrefixOperatorExpr>+<IntegerLiteralExpr>10</IntegerLiteralExpr></PrefixOperatorExpr></TupleExprElement>)</FunctionCallExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
    bar</DeclNameRef></IdentifierExpr>(<TupleExprElement><PrefixOperatorExpr>-<IntegerLiteralExpr>10</IntegerLiteralExpr></PrefixOperatorExpr></TupleExprElement>)</FunctionCallExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
    bar1</DeclNameRef></IdentifierExpr>(<TupleExprElement><PrefixOperatorExpr>-<FloatLiteralExpr>1.1</FloatLiteralExpr></PrefixOperatorExpr></TupleExprElement>)</FunctionCallExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
    bar1</DeclNameRef></IdentifierExpr>(<TupleExprElement><FloatLiteralExpr>1.1</FloatLiteralExpr></TupleExprElement>)</FunctionCallExpr><VariableDecl>
    var <PatternBinding><IdentifierPattern>f </IdentifierPattern><InitializerClause>= <PrefixOperatorExpr>/*comments*/+<FloatLiteralExpr>0.1</FloatLiteralExpr></PrefixOperatorExpr></InitializerClause></PatternBinding></VariableDecl><FunctionCallExpr><IdentifierExpr><DeclNameRef>/*comments*/
    foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><StringLiteralExpr>"<StringSegment>ðŸ™‚ðŸ¤—ðŸ¤©ðŸ¤”ðŸ¤¨</StringSegment>"</StringLiteralExpr></SequenceExpr>
  }</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>

  func foo1<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar2</DeclNameRef></IdentifierExpr>(<TupleExprElement>a:<IntegerLiteralExpr>1</IntegerLiteralExpr>, </TupleExprElement><TupleExprElement>b:<IntegerLiteralExpr>2</IntegerLiteralExpr>, </TupleExprElement><TupleExprElement>c:<IntegerLiteralExpr>2</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar2</DeclNameRef></IdentifierExpr>(<TupleExprElement>a:<SequenceExpr><IntegerLiteralExpr>1 </IntegerLiteralExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><IntegerLiteralExpr>1</IntegerLiteralExpr></SequenceExpr>, </TupleExprElement><TupleExprElement>b:<SequenceExpr><IntegerLiteralExpr>2 </IntegerLiteralExpr><BinaryOperatorExpr>* </BinaryOperatorExpr><IntegerLiteralExpr>2 </IntegerLiteralExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><IntegerLiteralExpr>2</IntegerLiteralExpr></SequenceExpr>, </TupleExprElement><TupleExprElement>c:<SequenceExpr><IntegerLiteralExpr>2 </IntegerLiteralExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><IntegerLiteralExpr>2</IntegerLiteralExpr></SequenceExpr></TupleExprElement>)</FunctionCallExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar2</DeclNameRef></IdentifierExpr>(<TupleExprElement>a : <FunctionCallExpr><IdentifierExpr><DeclNameRef>bar2</DeclNameRef></IdentifierExpr>(<TupleExprElement>a: <IntegerLiteralExpr>1</IntegerLiteralExpr>, </TupleExprElement><TupleExprElement>b: <IntegerLiteralExpr>2</IntegerLiteralExpr>, </TupleExprElement><TupleExprElement>c: <IntegerLiteralExpr>3</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr>, </TupleExprElement><TupleExprElement>b: <IntegerLiteralExpr>2</IntegerLiteralExpr>, </TupleExprElement><TupleExprElement>c: <IntegerLiteralExpr>3</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a : <FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a: <FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a: <IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr></TupleExprElement>)</FunctionCallExpr></TupleExprElement>)</FunctionCallExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar4</DeclNameRef></IdentifierExpr>(<TupleExprElement><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar4</DeclNameRef></IdentifierExpr>(<TupleExprElement><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar4</DeclNameRef></IdentifierExpr>(<TupleExprElement><IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr></TupleExprElement>)</FunctionCallExpr></TupleExprElement>)</FunctionCallExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><DictionaryExpr>[:]</DictionaryExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ArrayExpr>[]</ArrayExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ArrayExpr>[<ArrayElement><IntegerLiteralExpr>1</IntegerLiteralExpr>, </ArrayElement><ArrayElement><IntegerLiteralExpr>2</IntegerLiteralExpr>, </ArrayElement><ArrayElement><IntegerLiteralExpr>3</IntegerLiteralExpr>, </ArrayElement><ArrayElement><IntegerLiteralExpr>4</IntegerLiteralExpr></ArrayElement>]</ArrayExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><DictionaryExpr>[<DictionaryElement><IntegerLiteralExpr>1</IntegerLiteralExpr>:<IntegerLiteralExpr>1</IntegerLiteralExpr>, </DictionaryElement><DictionaryElement><IntegerLiteralExpr>2</IntegerLiteralExpr>:<IntegerLiteralExpr>2</IntegerLiteralExpr>, </DictionaryElement><DictionaryElement><IntegerLiteralExpr>3</IntegerLiteralExpr>:<IntegerLiteralExpr>3</IntegerLiteralExpr>, </DictionaryElement><DictionaryElement><IntegerLiteralExpr>4</IntegerLiteralExpr>:<IntegerLiteralExpr>4</IntegerLiteralExpr></DictionaryElement>]</DictionaryExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ArrayExpr>[<ArrayElement><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a:<IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr>, </ArrayElement><ArrayElement><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a:<IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr>, </ArrayElement><ArrayElement><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a:<IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr>, </ArrayElement><ArrayElement><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a:<IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr></ArrayElement>]</ArrayExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><DictionaryExpr>[<DictionaryElement><StringLiteralExpr>"<StringSegment>a</StringSegment>"</StringLiteralExpr>: <FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a:<IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr>, </DictionaryElement><DictionaryElement><StringLiteralExpr>"<StringSegment>b</StringSegment>"</StringLiteralExpr>: <FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a:<IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr>, </DictionaryElement><DictionaryElement><StringLiteralExpr>"<StringSegment>c</StringSegment>"</StringLiteralExpr>: <FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a:<IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr>, </DictionaryElement><DictionaryElement><StringLiteralExpr>"<StringSegment>d</StringSegment>"</StringLiteralExpr>: <FunctionCallExpr><IdentifierExpr><DeclNameRef>bar3</DeclNameRef></IdentifierExpr>(<TupleExprElement>a:<IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr></DictionaryElement>]</DictionaryExpr></SequenceExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
    foo</DeclNameRef></IdentifierExpr>(<TupleExprElement><NilLiteralExpr>nil</NilLiteralExpr>, </TupleExprElement><TupleExprElement><NilLiteralExpr>nil</NilLiteralExpr>, </TupleExprElement><TupleExprElement><NilLiteralExpr>nil</NilLiteralExpr></TupleExprElement>)</FunctionCallExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>type</DeclNameRef></IdentifierExpr>(<TupleExprElement>of: <IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr></TupleExprElement>)</FunctionCallExpr>.self</MemberAccessExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr>.<DeclNameRef>`self`</DeclNameRef></MemberAccessExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><IdentifierExpr><DeclNameRef>A </DeclNameRef></IdentifierExpr><ArrowExpr>-> </ArrowExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>B</DeclNameRef></IdentifierExpr>.<DeclNameRef>C</DeclNameRef></MemberAccessExpr><BinaryOperatorExpr><</BinaryOperatorExpr><PostfixUnaryExpr><IdentifierExpr><DeclNameRef>Int</DeclNameRef></IdentifierExpr>></PostfixUnaryExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><FunctionCallExpr><ArrayExpr>[<ArrayElement><SequenceExpr><TupleExpr>(<TupleExprElement><IdentifierExpr><DeclNameRef>A</DeclNameRef></IdentifierExpr></TupleExprElement>) </TupleExpr><ArrowExpr>throws -> </ArrowExpr><IdentifierExpr><DeclNameRef>B</DeclNameRef></IdentifierExpr></SequenceExpr></ArrayElement>]</ArrayExpr>()</FunctionCallExpr></SequenceExpr>
  }</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>
  func boolAnd<FunctionSignature><ParameterClause>() </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Bool </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <SequenceExpr><BooleanLiteralExpr>true </BooleanLiteralExpr><BinaryOperatorExpr>&& </BinaryOperatorExpr><BooleanLiteralExpr>false </BooleanLiteralExpr></SequenceExpr></ReturnStmt>}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>
  func boolOr<FunctionSignature><ParameterClause>() </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Bool </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <SequenceExpr><BooleanLiteralExpr>true </BooleanLiteralExpr><BinaryOperatorExpr>|| </BinaryOperatorExpr><BooleanLiteralExpr>false </BooleanLiteralExpr></SequenceExpr></ReturnStmt>}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>

  func foo2<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><TernaryExpr><BooleanLiteralExpr>true </BooleanLiteralExpr>? <IntegerLiteralExpr>1 </IntegerLiteralExpr>: <IntegerLiteralExpr>0</IntegerLiteralExpr></TernaryExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><TernaryExpr><TupleExpr>(<TupleExprElement><SequenceExpr><TernaryExpr><BooleanLiteralExpr>true </BooleanLiteralExpr>? <IntegerLiteralExpr>1 </IntegerLiteralExpr>: <IntegerLiteralExpr>0</IntegerLiteralExpr></TernaryExpr></SequenceExpr></TupleExprElement>) </TupleExpr>? <TupleExpr>(<TupleExprElement><SequenceExpr><TernaryExpr><BooleanLiteralExpr>true </BooleanLiteralExpr>? <IntegerLiteralExpr>1 </IntegerLiteralExpr>: <IntegerLiteralExpr>0</IntegerLiteralExpr></TernaryExpr></SequenceExpr></TupleExprElement>) </TupleExpr>: <TupleExpr>(<TupleExprElement><SequenceExpr><TernaryExpr><BooleanLiteralExpr>true </BooleanLiteralExpr>? <IntegerLiteralExpr>1 </IntegerLiteralExpr>: <IntegerLiteralExpr>0</IntegerLiteralExpr></TernaryExpr></SequenceExpr></TupleExprElement>)</TupleExpr></TernaryExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><TupleExpr>(<TupleExprElement><IntegerLiteralExpr>1</IntegerLiteralExpr>, </TupleExprElement><TupleExprElement><IntegerLiteralExpr>2</IntegerLiteralExpr></TupleExprElement>)</TupleExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><TupleExpr>(<TupleExprElement>first: <IntegerLiteralExpr>1</IntegerLiteralExpr>, </TupleExprElement><TupleExprElement>second: <IntegerLiteralExpr>2</IntegerLiteralExpr></TupleExprElement>)</TupleExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><TupleExpr>(<TupleExprElement><IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</TupleExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><TupleExpr>(<TupleExprElement>first: <IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</TupleExpr></SequenceExpr><IfStmt>
    if <ConditionElement><PrefixOperatorExpr>!<BooleanLiteralExpr>true </BooleanLiteralExpr></PrefixOperatorExpr></ConditionElement><CodeBlock>{<ReturnStmt>
      return</ReturnStmt>
    }</CodeBlock></IfStmt>
  }</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>

  func foo3<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><FunctionCallExpr><ArrayExpr>[<ArrayElement><TypeExpr><SimpleTypeIdentifier><DeclNameRef>Any</DeclNameRef></SimpleTypeIdentifier></TypeExpr></ArrayElement>]</ArrayExpr>()</FunctionCallExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr><TupleExpr>(<TupleExprElement><TypeExpr><AttributedType><Attribute>@convention(c) </Attribute><FunctionType>(<TupleTypeElement><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></TupleTypeElement>) -> <SimpleTypeIdentifier><DeclNameRef>Void</DeclNameRef></SimpleTypeIdentifier></FunctionType></AttributedType></TypeExpr></TupleExprElement>)</TupleExpr>.self</MemberAccessExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr>.<DeclNameRef>a</DeclNameRef></MemberAccessExpr>.<DeclNameRef>a</DeclNameRef></MemberAccessExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr>.<DeclNameRef>b</DeclNameRef></MemberAccessExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr><IntegerLiteralExpr>1</IntegerLiteralExpr>.<DeclNameRef>a</DeclNameRef></MemberAccessExpr></SequenceExpr><MemberAccessExpr><MemberAccessExpr><MemberAccessExpr><TupleExpr>
    (<TupleExprElement><SequenceExpr><IntegerLiteralExpr>1 </IntegerLiteralExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><IntegerLiteralExpr>1</IntegerLiteralExpr></SequenceExpr></TupleExprElement>)</TupleExpr>.<DeclNameRef>a</DeclNameRef></MemberAccessExpr>.<DeclNameRef>b</DeclNameRef></MemberAccessExpr>.<DeclNameRef>foo</DeclNameRef></MemberAccessExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><IdentifierExpr><DeclNameRef>a </DeclNameRef></IdentifierExpr><AsExpr>as <SimpleTypeIdentifier><DeclNameRef>Bool </DeclNameRef></SimpleTypeIdentifier></AsExpr><BinaryOperatorExpr>|| </BinaryOperatorExpr><IdentifierExpr><DeclNameRef>a </DeclNameRef></IdentifierExpr><AsExpr>as! <SimpleTypeIdentifier><DeclNameRef>Bool </DeclNameRef></SimpleTypeIdentifier></AsExpr><BinaryOperatorExpr>|| </BinaryOperatorExpr><IdentifierExpr><DeclNameRef>a </DeclNameRef></IdentifierExpr><AsExpr>as? <SimpleTypeIdentifier><DeclNameRef>Bool</DeclNameRef></SimpleTypeIdentifier></AsExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><IdentifierExpr><DeclNameRef>a </DeclNameRef></IdentifierExpr><IsExpr>is <SimpleTypeIdentifier><DeclNameRef>Bool</DeclNameRef></SimpleTypeIdentifier></IsExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><IdentifierExpr><DeclNameRef>self</DeclNameRef></IdentifierExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><IdentifierExpr><DeclNameRef>Self</DeclNameRef></IdentifierExpr></SequenceExpr>
  }</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>

  func superExpr<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr><SuperRefExpr>super</SuperRefExpr>.<DeclNameRef>foo</DeclNameRef></MemberAccessExpr></SequenceExpr><FunctionCallExpr><MemberAccessExpr><SuperRefExpr>
    super</SuperRefExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>()</FunctionCallExpr><SequenceExpr><SubscriptExpr><SuperRefExpr>
    super</SuperRefExpr>[<TupleExprElement><IntegerLiteralExpr>12</IntegerLiteralExpr></TupleExprElement>] </SubscriptExpr><AssignmentExpr>= </AssignmentExpr><IntegerLiteralExpr>1</IntegerLiteralExpr></SequenceExpr><FunctionCallExpr><MemberAccessExpr><SuperRefExpr>
    super</SuperRefExpr>.<DeclNameRef>init</DeclNameRef></MemberAccessExpr>()</FunctionCallExpr>
  }</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>

  func implictMember<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr>.<DeclNameRef>foo</DeclNameRef></MemberAccessExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><FunctionCallExpr><MemberAccessExpr>.<DeclNameRef>foo</DeclNameRef></MemberAccessExpr>(<TupleExprElement>x: <IntegerLiteralExpr>12</IntegerLiteralExpr></TupleExprElement>)</FunctionCallExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><FunctionCallExpr><MemberAccessExpr>.<DeclNameRef>foo</DeclNameRef></MemberAccessExpr>() <ClosureExpr>{ <IntegerLiteralExpr>12 </IntegerLiteralExpr>}</ClosureExpr></FunctionCallExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><SubscriptExpr><MemberAccessExpr>.<DeclNameRef>foo</DeclNameRef></MemberAccessExpr>[<TupleExprElement><IntegerLiteralExpr>12</IntegerLiteralExpr></TupleExprElement>]</SubscriptExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
    _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr><MemberAccessExpr>.<DeclNameRef>foo</DeclNameRef></MemberAccessExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr></SequenceExpr>
  }</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><InitializerDecl>

  init<ParameterClause>() </ParameterClause><CodeBlock>{}</CodeBlock></InitializerDecl></MemberDeclListItem><MemberDeclListItem><InitializerDecl><Attribute>
  @objc </Attribute><DeclModifier>private </DeclModifier>init<ParameterClause>(<FunctionParameter>a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>)</ParameterClause></InitializerDecl></MemberDeclListItem><MemberDeclListItem><InitializerDecl>
  init!<ParameterClause>(<FunctionParameter>a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><CodeBlock>{}</CodeBlock></InitializerDecl></MemberDeclListItem><MemberDeclListItem><InitializerDecl>
  init?<ParameterClause>(<FunctionParameter>a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><CodeBlock>{}</CodeBlock></InitializerDecl></MemberDeclListItem><MemberDeclListItem><InitializerDecl><DeclModifier>
  public </DeclModifier>init<ParameterClause>(<FunctionParameter>a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause>throws <CodeBlock>{}</CodeBlock></InitializerDecl></MemberDeclListItem><MemberDeclListItem><InitializerDecl>
  init<ParameterClause>(<FunctionParameter>a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>..., </FunctionParameter><FunctionParameter>b: <SimpleTypeIdentifier><DeclNameRef>Double</DeclNameRef></SimpleTypeIdentifier>...</FunctionParameter>) </ParameterClause><CodeBlock>{}</CodeBlock></InitializerDecl></MemberDeclListItem><MemberDeclListItem><DeinitializerDecl><Attribute>

  @objc </Attribute>deinit <CodeBlock>{}</CodeBlock></DeinitializerDecl></MemberDeclListItem><MemberDeclListItem><DeinitializerDecl><DeclModifier>
  private </DeclModifier>deinit <CodeBlock>{}</CodeBlock></DeinitializerDecl></MemberDeclListItem><MemberDeclListItem><SubscriptDecl><DeclModifier>

  internal </DeclModifier>subscript<ParameterClause>(<FunctionParameter>x: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause><AccessorBlock>{ <AccessorDecl>get <CodeBlock>{} </CodeBlock></AccessorDecl><AccessorDecl>set <CodeBlock>{} </CodeBlock></AccessorDecl>}</AccessorBlock></SubscriptDecl></MemberDeclListItem><MemberDeclListItem><SubscriptDecl>
  subscript<ParameterClause>() </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>1 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></SubscriptDecl></MemberDeclListItem><MemberDeclListItem><SubscriptDecl>
  subscript<ParameterClause>(<FunctionParameter>x: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>..., </FunctionParameter><FunctionParameter>y y: <SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier>...</FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>1 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></SubscriptDecl></MemberDeclListItem><MemberDeclListItem><VariableDecl>

  var <PatternBinding><IdentifierPattern>x</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><CodeBlock>{<FunctionCallExpr><IdentifierExpr><DeclNameRef>
    address </DeclNameRef></IdentifierExpr><ClosureExpr>{ <FunctionCallExpr><IdentifierExpr><DeclNameRef>fatalError</DeclNameRef></IdentifierExpr>() </FunctionCallExpr>}</ClosureExpr></FunctionCallExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
    unsafeMutableAddress </DeclNameRef></IdentifierExpr><ClosureExpr>{ <FunctionCallExpr><IdentifierExpr><DeclNameRef>fatalError</DeclNameRef></IdentifierExpr>() </FunctionCallExpr>}</ClosureExpr></FunctionCallExpr>
  }</CodeBlock></PatternBinding></VariableDecl></MemberDeclListItem>
}</MemberDeclBlock></ClassDecl><ProtocolDecl>

protocol PP <MemberDeclBlock>{<MemberDeclListItem><AssociatedtypeDecl>
  associatedtype A</AssociatedtypeDecl></MemberDeclListItem><MemberDeclListItem><AssociatedtypeDecl>
  associatedtype B<TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>Sequence</DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause></AssociatedtypeDecl></MemberDeclListItem><MemberDeclListItem><AssociatedtypeDecl>
  associatedtype C <TypeInitializerClause>= <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></TypeInitializerClause></AssociatedtypeDecl></MemberDeclListItem><MemberDeclListItem><AssociatedtypeDecl>
  associatedtype D<TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>Sequence </DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause><TypeInitializerClause>= <ArrayType>[<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>]</ArrayType></TypeInitializerClause></AssociatedtypeDecl></MemberDeclListItem><MemberDeclListItem><AssociatedtypeDecl>
  associatedtype E<TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>Sequence </DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause><TypeInitializerClause>= <ArrayType>[<ArrayType>[<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>]</ArrayType>] </ArrayType></TypeInitializerClause><GenericWhereClause>where <GenericRequirement><ConformanceRequirement><MemberTypeIdentifier><SimpleTypeIdentifier><DeclNameRef>A</DeclNameRef></SimpleTypeIdentifier>.<DeclNameRef>Element </DeclNameRef></MemberTypeIdentifier>: <SimpleTypeIdentifier><DeclNameRef>Sequence</DeclNameRef></SimpleTypeIdentifier></ConformanceRequirement></GenericRequirement></GenericWhereClause></AssociatedtypeDecl></MemberDeclListItem><MemberDeclListItem><AssociatedtypeDecl><DeclModifier>
  private </DeclModifier>associatedtype F</AssociatedtypeDecl></MemberDeclListItem><MemberDeclListItem><AssociatedtypeDecl><Attribute>
  @objc </Attribute>associatedtype G</AssociatedtypeDecl></MemberDeclListItem>
}</MemberDeclBlock></ProtocolDecl></IfConfigClause>

#endif</IfConfigDecl><IfConfigDecl><IfConfigClause>

#if <IdentifierExpr><DeclNameRef>blah</DeclNameRef></IdentifierExpr><TypealiasDecl>
typealias A <TypeInitializerClause>= <SimpleTypeIdentifier><DeclNameRef>Any</DeclNameRef></SimpleTypeIdentifier></TypeInitializerClause></TypealiasDecl></IfConfigClause><IfConfigClause>
#elseif <IdentifierExpr><DeclNameRef>blahblah</DeclNameRef></IdentifierExpr><TypealiasDecl>
typealias B <TypeInitializerClause>= <TupleType>(<TupleTypeElement><MemberTypeIdentifier><SimpleTypeIdentifier><DeclNameRef>Array</DeclNameRef><GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier><DeclNameRef>Array</DeclNameRef><GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier><DeclNameRef>Any</DeclNameRef></SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></SimpleTypeIdentifier>.<DeclNameRef>Element</DeclNameRef></MemberTypeIdentifier>, </TupleTypeElement><TupleTypeElement>x: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></TupleTypeElement>)</TupleType></TypeInitializerClause></TypealiasDecl></IfConfigClause><IfConfigClause>
#else<TypealiasDecl>
typealias C <TypeInitializerClause>= <ArrayType>[<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>]</ArrayType></TypeInitializerClause></TypealiasDecl></IfConfigClause>
#endif</IfConfigDecl><TypealiasDecl>
typealias D <TypeInitializerClause>= <DictionaryType>[<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>: <SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier>]</DictionaryType></TypeInitializerClause></TypealiasDecl><TypealiasDecl>
typealias E <TypeInitializerClause>= <MetatypeType><OptionalType><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>?</OptionalType>.Protocol</MetatypeType></TypeInitializerClause></TypealiasDecl><TypealiasDecl>
typealias F <TypeInitializerClause>= <MetatypeType><ImplicitlyUnwrappedOptionalType><ArrayType>[<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>]</ArrayType>!</ImplicitlyUnwrappedOptionalType>.Type</MetatypeType></TypeInitializerClause></TypealiasDecl><TypealiasDecl>
typealias G <TypeInitializerClause>= <FunctionType>(<TupleTypeElement>a x: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement>_ y: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier>... <InitializerClause>= <IntegerLiteralExpr>1</IntegerLiteralExpr></InitializerClause></TupleTypeElement>) throw -> <FunctionType>() -> <TupleType>()</TupleType></FunctionType></FunctionType></TypeInitializerClause></TypealiasDecl><TypealiasDecl>
typealias H <TypeInitializerClause>= <FunctionType>() rethrows -> <TupleType>()</TupleType></FunctionType></TypeInitializerClause></TypealiasDecl><TypealiasDecl>
typealias I <TypeInitializerClause>= <FunctionType>(<TupleTypeElement><CompositionType><CompositionTypeElement><SimpleTypeIdentifier><DeclNameRef>A </DeclNameRef></SimpleTypeIdentifier>& </CompositionTypeElement><CompositionTypeElement><SimpleTypeIdentifier><DeclNameRef>B</DeclNameRef><GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier><DeclNameRef>C</DeclNameRef></SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></SimpleTypeIdentifier></CompositionTypeElement></CompositionType></TupleTypeElement>) -> <CompositionType><CompositionTypeElement><SimpleTypeIdentifier><DeclNameRef>C </DeclNameRef></SimpleTypeIdentifier>& </CompositionTypeElement><CompositionTypeElement><SimpleTypeIdentifier><DeclNameRef>D</DeclNameRef></SimpleTypeIdentifier></CompositionTypeElement></CompositionType></FunctionType></TypeInitializerClause></TypealiasDecl><TypealiasDecl>
typealias J <TypeInitializerClause>= <AttributedType>inout <Attribute>@autoclosure </Attribute><FunctionType>() -> <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionType></AttributedType></TypeInitializerClause></TypealiasDecl><TypealiasDecl>
typealias K <TypeInitializerClause>= <FunctionType>(<TupleTypeElement><AttributedType><CustomAttribute>@<SimpleTypeIdentifier><DeclNameRef>invalidAttr </DeclNameRef></SimpleTypeIdentifier></CustomAttribute><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></AttributedType>, </TupleTypeElement><TupleTypeElement><AttributedType>inout <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></AttributedType>, </TupleTypeElement><TupleTypeElement><AttributedType>__shared <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></AttributedType>, </TupleTypeElement><TupleTypeElement><AttributedType>__owned <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></AttributedType></TupleTypeElement>) -> <TupleType>()</TupleType></FunctionType></TypeInitializerClause></TypealiasDecl><TypealiasDecl><Attribute>

@objc </Attribute><DeclModifier>private </DeclModifier>typealias T<GenericParameterClause><<GenericParameter>a,</GenericParameter><GenericParameter>b</GenericParameter>> </GenericParameterClause><TypeInitializerClause>= <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></TypeInitializerClause></TypealiasDecl><TypealiasDecl><Attribute>
@objc </Attribute><DeclModifier>private </DeclModifier>typealias T<GenericParameterClause><<GenericParameter>a,</GenericParameter><GenericParameter>b</GenericParameter>></GenericParameterClause></TypealiasDecl><ClassDecl>

class Foo <MemberDeclBlock>{<MemberDeclListItem><VariableDecl>
  let <PatternBinding><IdentifierPattern>bar</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></TypeAnnotation></PatternBinding></VariableDecl></MemberDeclListItem>
}</MemberDeclBlock></ClassDecl><ClassDecl>

class Bar<TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>Foo </DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause><MemberDeclBlock>{<MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>foo</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><InitializerClause>= <IntegerLiteralExpr>42</IntegerLiteralExpr></InitializerClause></PatternBinding></VariableDecl></MemberDeclListItem>
}</MemberDeclBlock></ClassDecl><ClassDecl>

class C<GenericParameterClause><<GenericParameter>A, </GenericParameter><GenericParameter>B</GenericParameter>> </GenericParameterClause><GenericWhereClause>where <GenericRequirement><ConformanceRequirement><SimpleTypeIdentifier><DeclNameRef>A</DeclNameRef></SimpleTypeIdentifier>: <SimpleTypeIdentifier><DeclNameRef>Foo</DeclNameRef></SimpleTypeIdentifier></ConformanceRequirement>, </GenericRequirement><GenericRequirement><SameTypeRequirement><SimpleTypeIdentifier><DeclNameRef>B </DeclNameRef></SimpleTypeIdentifier>== <SimpleTypeIdentifier><DeclNameRef>Bar </DeclNameRef></SimpleTypeIdentifier></SameTypeRequirement></GenericRequirement></GenericWhereClause><MemberDeclBlock>{}</MemberDeclBlock></ClassDecl><ClassDecl><Attribute>

@available(<AvailabilityArgument>*, </AvailabilityArgument><AvailabilityArgument>unavailable</AvailabilityArgument>)</Attribute><DeclModifier>
private </DeclModifier>class C <MemberDeclBlock>{}</MemberDeclBlock></ClassDecl><StructDecl>

struct foo <MemberDeclBlock>{<MemberDeclListItem><StructDecl>
  struct foo <MemberDeclBlock>{<MemberDeclListItem><StructDecl>
    struct foo <MemberDeclBlock>{<MemberDeclListItem><FunctionDecl>
      func foo<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{
      }</CodeBlock></FunctionDecl></MemberDeclListItem>
    }</MemberDeclBlock></StructDecl></MemberDeclListItem>
  }</MemberDeclBlock></StructDecl></MemberDeclListItem><MemberDeclListItem><StructDecl>
  struct foo <MemberDeclBlock>{}</MemberDeclBlock></StructDecl></MemberDeclListItem>
}</MemberDeclBlock></StructDecl><StructDecl>

struct foo <MemberDeclBlock>{<MemberDeclListItem><StructDecl><Attribute>
  @available(<AvailabilityArgument>*, </AvailabilityArgument><AvailabilityArgument>unavailable</AvailabilityArgument>)</Attribute>
  struct foo <MemberDeclBlock>{}</MemberDeclBlock></StructDecl></MemberDeclListItem><MemberDeclListItem><ClassDecl><DeclModifier>
  public </DeclModifier>class foo <MemberDeclBlock>{<MemberDeclListItem><FunctionDecl><Attribute>
    @available(<AvailabilityArgument>*, </AvailabilityArgument><AvailabilityArgument>unavailable</AvailabilityArgument>)</Attribute><Attribute>
    @objc(<ObjCSelectorPiece>fooObjc</ObjCSelectorPiece>)</Attribute><DeclModifier>
    private </DeclModifier><DeclModifier>static </DeclModifier>func foo<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl><Attribute>
    
    @objc(<ObjCSelectorPiece>fooObjcBar:</ObjCSelectorPiece><ObjCSelectorPiece>baz:</ObjCSelectorPiece>)</Attribute><DeclModifier>
    private </DeclModifier><DeclModifier>static </DeclModifier>func foo<FunctionSignature><ParameterClause>(<FunctionParameter>bar: <SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>baz: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>)</ParameterClause></FunctionSignature></FunctionDecl></MemberDeclListItem>
  }</MemberDeclBlock></ClassDecl></MemberDeclListItem>
}</MemberDeclBlock></StructDecl><StructDecl>

struct S<GenericParameterClause><<GenericParameter>A, </GenericParameter><GenericParameter>B, </GenericParameter><GenericParameter>C, </GenericParameter><GenericParameter><Attribute>@objc </Attribute>D</GenericParameter>> </GenericParameterClause><GenericWhereClause>where <GenericRequirement><ConformanceRequirement><SimpleTypeIdentifier><DeclNameRef>A</DeclNameRef></SimpleTypeIdentifier>:<SimpleTypeIdentifier><DeclNameRef>B</DeclNameRef></SimpleTypeIdentifier></ConformanceRequirement>, </GenericRequirement><GenericRequirement><SameTypeRequirement><SimpleTypeIdentifier><DeclNameRef>B</DeclNameRef></SimpleTypeIdentifier>==<SimpleTypeIdentifier><DeclNameRef>C</DeclNameRef></SimpleTypeIdentifier></SameTypeRequirement>, </GenericRequirement><GenericRequirement><ConformanceRequirement><SimpleTypeIdentifier><DeclNameRef>A </DeclNameRef></SimpleTypeIdentifier>: <SimpleTypeIdentifier><DeclNameRef>C</DeclNameRef></SimpleTypeIdentifier></ConformanceRequirement>, </GenericRequirement><GenericRequirement><SameTypeRequirement><MemberTypeIdentifier><SimpleTypeIdentifier><DeclNameRef>B</DeclNameRef></SimpleTypeIdentifier>.<DeclNameRef>C </DeclNameRef></MemberTypeIdentifier>== <MemberTypeIdentifier><SimpleTypeIdentifier><DeclNameRef>D</DeclNameRef></SimpleTypeIdentifier>.<DeclNameRef>A</DeclNameRef></MemberTypeIdentifier></SameTypeRequirement>, </GenericRequirement><GenericRequirement><ConformanceRequirement><MemberTypeIdentifier><SimpleTypeIdentifier><DeclNameRef>A</DeclNameRef></SimpleTypeIdentifier>.<DeclNameRef>B</DeclNameRef></MemberTypeIdentifier>: <MemberTypeIdentifier><SimpleTypeIdentifier><DeclNameRef>C</DeclNameRef></SimpleTypeIdentifier>.<DeclNameRef>D </DeclNameRef></MemberTypeIdentifier></ConformanceRequirement></GenericRequirement></GenericWhereClause><MemberDeclBlock>{}</MemberDeclBlock></StructDecl><StructDecl><DeclModifier>

private </DeclModifier>struct S<GenericParameterClause><<GenericParameter>A, </GenericParameter><GenericParameter>B</GenericParameter>></GenericParameterClause><TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>Base </DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause><GenericWhereClause>where <GenericRequirement><ConformanceRequirement><SimpleTypeIdentifier><DeclNameRef>A</DeclNameRef></SimpleTypeIdentifier>: <SimpleTypeIdentifier><DeclNameRef>B </DeclNameRef></SimpleTypeIdentifier></ConformanceRequirement></GenericRequirement></GenericWhereClause><MemberDeclBlock>{<MemberDeclListItem><StructDecl><DeclModifier>
  private </DeclModifier>struct S<TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>A</DeclNameRef></SimpleTypeIdentifier>, </InheritedType><InheritedType><SimpleTypeIdentifier><DeclNameRef>B </DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause><MemberDeclBlock>{}</MemberDeclBlock></StructDecl></MemberDeclListItem>
}</MemberDeclBlock></StructDecl><ProtocolDecl>

protocol P<TypeInheritanceClause>: <InheritedType><ClassRestrictionType>class </ClassRestrictionType></InheritedType></TypeInheritanceClause><MemberDeclBlock>{}</MemberDeclBlock></ProtocolDecl><FunctionDecl>

func foo<FunctionSignature><ParameterClause>(<FunctionParameter>_ _: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>,</FunctionParameter><FunctionParameter>
         a b: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier><InitializerClause>= <SequenceExpr><IntegerLiteralExpr>3 </IntegerLiteralExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><IntegerLiteralExpr>2</IntegerLiteralExpr></SequenceExpr></InitializerClause>,</FunctionParameter><FunctionParameter>
         _ c: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier><InitializerClause>= <IntegerLiteralExpr>2</IntegerLiteralExpr></InitializerClause>,</FunctionParameter><FunctionParameter>
         d _: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier><InitializerClause>= <SequenceExpr><TernaryExpr><BooleanLiteralExpr>true </BooleanLiteralExpr>? <IntegerLiteralExpr>2</IntegerLiteralExpr>: <IntegerLiteralExpr>3</IntegerLiteralExpr></TernaryExpr></SequenceExpr></InitializerClause>,</FunctionParameter><FunctionParameter><Attribute>
         @objc </Attribute>e: <SimpleTypeIdentifier><DeclNameRef>X </DeclNameRef></SimpleTypeIdentifier><InitializerClause>= <BooleanLiteralExpr>true</BooleanLiteralExpr></InitializerClause>,</FunctionParameter><FunctionParameter>
         f: <AttributedType>inout <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></AttributedType>,</FunctionParameter><FunctionParameter>
         g: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>...,</FunctionParameter><FunctionParameter>
         h: <SimpleTypeIdentifier><DeclNameRef>Bool</DeclNameRef></SimpleTypeIdentifier>...</FunctionParameter>) </ParameterClause>throws <ReturnClause>-> <DictionaryType>[<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>: <SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier>] </DictionaryType></ReturnClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl><FunctionDecl>

func foo<FunctionSignature><ParameterClause>(<FunctionParameter>_ a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause>throws <ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl><FunctionDecl>
func foo<FunctionSignature><ParameterClause>( <FunctionParameter>a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause>rethrows <ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl><StructDecl>

struct C <MemberDeclBlock>{<MemberDeclListItem><FunctionDecl><Attribute>
@objc</Attribute><Attribute>
@available(<AvailabilityArgument>*, </AvailabilityArgument><AvailabilityArgument>unavailable</AvailabilityArgument>)</Attribute><DeclModifier>
private </DeclModifier><DeclModifier>static </DeclModifier><DeclModifier>override </DeclModifier>func foo<GenericParameterClause><<GenericParameter>a, </GenericParameter><GenericParameter>b, </GenericParameter><GenericParameter>c</GenericParameter>></GenericParameterClause><FunctionSignature><ParameterClause>(<FunctionParameter>a b: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>c: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause>throws <ReturnClause>-> <ArrayType>[<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>] </ArrayType></ReturnClause></FunctionSignature><GenericWhereClause>where <GenericRequirement><SameTypeRequirement><SimpleTypeIdentifier><DeclNameRef>a</DeclNameRef></SimpleTypeIdentifier>==<SimpleTypeIdentifier><DeclNameRef>p1</DeclNameRef></SimpleTypeIdentifier></SameTypeRequirement>, </GenericRequirement><GenericRequirement><ConformanceRequirement><SimpleTypeIdentifier><DeclNameRef>b</DeclNameRef></SimpleTypeIdentifier>:<SimpleTypeIdentifier><DeclNameRef>p2 </DeclNameRef></SimpleTypeIdentifier></ConformanceRequirement></GenericRequirement></GenericWhereClause><CodeBlock>{ <IdentifierExpr><DeclNameRef>ddd </DeclNameRef></IdentifierExpr>}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>
func rootView<FunctionSignature><ParameterClause>() </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Label </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl><DeclModifier>
static </DeclModifier>func ==<FunctionSignature><ParameterClause>() </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>bool </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl><DeclModifier>
static </DeclModifier>func !=<GenericParameterClause><<GenericParameter>a, </GenericParameter><GenericParameter>b, </GenericParameter><GenericParameter>c</GenericParameter>></GenericParameterClause><FunctionSignature><ParameterClause>() </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>bool </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl></MemberDeclListItem>
}</MemberDeclBlock></StructDecl><ProtocolDecl><Attribute>

@objc</Attribute><DeclModifier>
private </DeclModifier>protocol foo <TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>bar </DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause><GenericWhereClause>where <GenericRequirement><SameTypeRequirement><SimpleTypeIdentifier><DeclNameRef>A</DeclNameRef></SimpleTypeIdentifier>==<SimpleTypeIdentifier><DeclNameRef>B </DeclNameRef></SimpleTypeIdentifier></SameTypeRequirement></GenericRequirement></GenericWhereClause><MemberDeclBlock>{}</MemberDeclBlock></ProtocolDecl><ProtocolDecl>
protocol foo <MemberDeclBlock>{ <MemberDeclListItem><FunctionDecl>func foo<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature></FunctionDecl></MemberDeclListItem>}</MemberDeclBlock></ProtocolDecl><ProtocolDecl><DeclModifier>
private </DeclModifier>protocol foo<MemberDeclBlock>{}</MemberDeclBlock></ProtocolDecl><ProtocolDecl><Attribute>
@objc</Attribute><DeclModifier>
public </DeclModifier>protocol foo <GenericWhereClause>where <GenericRequirement><ConformanceRequirement><SimpleTypeIdentifier><DeclNameRef>A</DeclNameRef></SimpleTypeIdentifier>:<SimpleTypeIdentifier><DeclNameRef>B </DeclNameRef></SimpleTypeIdentifier></ConformanceRequirement></GenericRequirement></GenericWhereClause><MemberDeclBlock>{}</MemberDeclBlock></ProtocolDecl><IfConfigDecl><IfConfigClause>

#if <IdentifierExpr><DeclNameRef>blah</DeclNameRef></IdentifierExpr><FunctionDecl>
func tryfoo<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<TryExpr>
  try <FunctionCallExpr><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr></TryExpr><TryExpr>
  try! <FunctionCallExpr><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr></TryExpr><TryExpr>
  try? <FunctionCallExpr><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr></TryExpr><TryExpr>
  try! <FunctionCallExpr><MemberAccessExpr><FunctionCallExpr><MemberAccessExpr><FunctionCallExpr><MemberAccessExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>()</FunctionCallExpr>.<DeclNameRef>foo</DeclNameRef></MemberAccessExpr>()</FunctionCallExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>()</FunctionCallExpr></TryExpr>
}</CodeBlock></FunctionDecl></IfConfigClause><IfConfigClause>
#else<FunctionDecl>
func closure<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{<ClosureSignature><ClosureCaptureSignature>[<ClosureCaptureItem>weak <IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr>,</ClosureCaptureItem><ClosureCaptureItem>
    unowned(safe) <IdentifierExpr><DeclNameRef>self</DeclNameRef></IdentifierExpr>,</ClosureCaptureItem><ClosureCaptureItem>
    b = <IntegerLiteralExpr>3</IntegerLiteralExpr>,</ClosureCaptureItem><ClosureCaptureItem>
    unowned(unsafe) c = <MemberAccessExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr></ClosureCaptureItem>] </ClosureCaptureSignature>in</ClosureSignature>
  }</ClosureExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{<ClosureSignature><ClosureCaptureSignature>[] </ClosureCaptureSignature>in </ClosureSignature>}</ClosureExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>

  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{ <ClosureSignature><ClosureCaptureSignature>[] </ClosureCaptureSignature><ClosureParam>a, </ClosureParam><ClosureParam>b, </ClosureParam><ClosureParam>_ </ClosureParam><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause>in</ClosureSignature><ReturnStmt>
    return <IntegerLiteralExpr>2</IntegerLiteralExpr></ReturnStmt>
  }</ClosureExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{ <ClosureSignature><ClosureCaptureSignature>[] </ClosureCaptureSignature><ParameterClause>(<FunctionParameter>a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>b: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>_: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause>in</ClosureSignature><ReturnStmt>
    return <IntegerLiteralExpr>2</IntegerLiteralExpr></ReturnStmt>
  }</ClosureExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{ <ClosureSignature><ClosureCaptureSignature>[] </ClosureCaptureSignature><ClosureParam>a, </ClosureParam><ClosureParam>b, </ClosureParam><ClosureParam>_ </ClosureParam>throws <ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause>in</ClosureSignature><ReturnStmt>
    return <IntegerLiteralExpr>2</IntegerLiteralExpr></ReturnStmt>
  }</ClosureExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{ <ClosureSignature><ClosureCaptureSignature>[] </ClosureCaptureSignature><ParameterClause>(<FunctionParameter>a: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>_ b: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause>throws <ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause>in</ClosureSignature><ReturnStmt>
    return <IntegerLiteralExpr>2</IntegerLiteralExpr></ReturnStmt>
  }</ClosureExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{ <ClosureSignature><ClosureParam>a, </ClosureParam><ClosureParam>b </ClosureParam>in </ClosureSignature>}</ClosureExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{ <ClosureSignature><ParameterClause>(<FunctionParameter>a, </FunctionParameter><FunctionParameter>b</FunctionParameter>) </ParameterClause>in </ClosureSignature>}</ClosureExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{}</ClosureExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{ <ClosureSignature><ClosureParam>s1, </ClosureParam><ClosureParam>s2 </ClosureParam>in </ClosureSignature><SequenceExpr><IdentifierExpr><DeclNameRef>s1 </DeclNameRef></IdentifierExpr><BinaryOperatorExpr>> </BinaryOperatorExpr><IdentifierExpr><DeclNameRef>s2 </DeclNameRef></IdentifierExpr></SequenceExpr>}</ClosureExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ClosureExpr>{ <SequenceExpr><IdentifierExpr><DeclNameRef>$0 </DeclNameRef></IdentifierExpr><BinaryOperatorExpr>> </BinaryOperatorExpr><IdentifierExpr><DeclNameRef>$1 </DeclNameRef></IdentifierExpr></SequenceExpr>}</ClosureExpr></SequenceExpr>
}</CodeBlock></FunctionDecl></IfConfigClause>
#endif</IfConfigDecl><FunctionDecl>

func postfix<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<FunctionCallExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>() <ClosureExpr>{}</ClosureExpr></FunctionCallExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
  foo </DeclNameRef></IdentifierExpr><ClosureExpr>{}</ClosureExpr></FunctionCallExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
  foo </DeclNameRef></IdentifierExpr><ClosureExpr>{ }</ClosureExpr><MultipleTrailingClosureElement>
    arg2: <ClosureExpr>{}</ClosureExpr></MultipleTrailingClosureElement></FunctionCallExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
  foo </DeclNameRef></IdentifierExpr><ClosureExpr>{}</ClosureExpr></FunctionCallExpr><FunctionCallExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>()</FunctionCallExpr><FunctionCallExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>() <ClosureExpr>{}</ClosureExpr></FunctionCallExpr><FunctionCallExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>() <ClosureExpr>{}</ClosureExpr><MultipleTrailingClosureElement>
    arg2: <ClosureExpr>{}</ClosureExpr></MultipleTrailingClosureElement><MultipleTrailingClosureElement>
    in: <ClosureExpr>{}</ClosureExpr></MultipleTrailingClosureElement></FunctionCallExpr><FunctionCallExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>.<DeclNameRef>bar </DeclNameRef></MemberAccessExpr><ClosureExpr>{}</ClosureExpr></FunctionCallExpr><SubscriptExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>[]</SubscriptExpr><SubscriptExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>[<TupleExprElement><IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>]</SubscriptExpr><SubscriptExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>[] <ClosureExpr>{}</ClosureExpr></SubscriptExpr><SubscriptExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>[<TupleExprElement><IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>] <ClosureExpr>{}</ClosureExpr></SubscriptExpr><SubscriptExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>[<TupleExprElement><IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>] <ClosureExpr>{}</ClosureExpr><MultipleTrailingClosureElement>
    arg2: <ClosureExpr>{}</ClosureExpr></MultipleTrailingClosureElement></SubscriptExpr><SubscriptExpr><SubscriptExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>[<TupleExprElement><IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>]</SubscriptExpr>[<TupleExprElement><IntegerLiteralExpr>2</IntegerLiteralExpr>,</TupleExprElement><TupleExprElement>x:<IntegerLiteralExpr>3</IntegerLiteralExpr></TupleExprElement>]</SubscriptExpr><MemberAccessExpr><FunctionCallExpr><ForcedValueExpr><MemberAccessExpr><PostfixUnaryExpr><OptionalChainingExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>?</OptionalChainingExpr>++</PostfixUnaryExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>!</ForcedValueExpr>(<TupleExprElement><IdentifierExpr><DeclNameRef>baz</DeclNameRef></IdentifierExpr></TupleExprElement>)</FunctionCallExpr>.self</MemberAccessExpr><MemberAccessExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr>.<DeclNameRef>0</DeclNameRef></MemberAccessExpr><MemberAccessExpr><SpecializeExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr><GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></SpecializeExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr><FunctionCallExpr><SpecializeExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr><GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></SpecializeExpr>()</FunctionCallExpr><FunctionCallExpr><SpecializeExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>
  foo</DeclNameRef></IdentifierExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr><GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></SpecializeExpr>()</FunctionCallExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>

  foo<DeclNameArguments>(<DeclNameArgument>x:</DeclNameArgument><DeclNameArgument>y:</DeclNameArgument>)</DeclNameArguments></DeclNameRef></IdentifierExpr>()</FunctionCallExpr><FunctionCallExpr><SpecializeExpr><IdentifierExpr><DeclNameRef>
  foo<DeclNameArguments>(<DeclNameArgument>x:</DeclNameArgument>)</DeclNameArguments></DeclNameRef></IdentifierExpr><GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></GenericArgument>> </GenericArgumentClause></SpecializeExpr><ClosureExpr>{ }</ClosureExpr></FunctionCallExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr>.<DeclNameRef>foo<DeclNameArguments>(<DeclNameArgument>x:</DeclNameArgument><DeclNameArgument>y:</DeclNameArgument>)</DeclNameArguments></DeclNameRef></MemberAccessExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>x</DeclNameRef></IdentifierExpr>.<DeclNameRef>foo<DeclNameArguments>(<DeclNameArgument>x:</DeclNameArgument><DeclNameArgument>y:</DeclNameArgument>)</DeclNameArguments></DeclNameRef></MemberAccessExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr>(<TupleExprElement><InOutExpr>&<IdentifierExpr><DeclNameRef>d</DeclNameRef></IdentifierExpr></InOutExpr></TupleExprElement>)</FunctionCallExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><EditorPlaceholderExpr><DeclNameRef><#Placeholder#> </DeclNameRef></EditorPlaceholderExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><EditorPlaceholderExpr><DeclNameRef><#T##(Int) -> Int#></DeclNameRef></EditorPlaceholderExpr></SequenceExpr>
}</CodeBlock></FunctionDecl><IfConfigDecl><IfConfigClause>

#if <IdentifierExpr><DeclNameRef>blah</DeclNameRef></IdentifierExpr></IfConfigClause><IfConfigClause>
#else</IfConfigClause>
#endif</IfConfigDecl><ClassDecl>

class C <MemberDeclBlock>{<MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>a</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><AccessorBlock>{<AccessorDecl><Attribute>
    @objc </Attribute><DeclModifier>mutating </DeclModifier>set<AccessorParameter>(value) </AccessorParameter><CodeBlock>{}</CodeBlock></AccessorDecl><AccessorDecl><DeclModifier>
    mutating </DeclModifier>get <CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>3 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></AccessorDecl><AccessorDecl><Attribute>
    @objc </Attribute>didSet <CodeBlock>{}</CodeBlock></AccessorDecl><AccessorDecl>
    willSet<AccessorParameter>(newValue)</AccessorParameter><CodeBlock>{ }</CodeBlock></AccessorDecl>
  }</AccessorBlock></PatternBinding></VariableDecl></MemberDeclListItem><MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>a </IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><CodeBlock>{<ReturnStmt>
    return <IntegerLiteralExpr>3</IntegerLiteralExpr></ReturnStmt>
  }</CodeBlock></PatternBinding></VariableDecl></MemberDeclListItem>
}</MemberDeclBlock></ClassDecl><ProtocolDecl>

protocol P <MemberDeclBlock>{<MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>a</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><AccessorBlock>{ <AccessorDecl>get </AccessorDecl><AccessorDecl>set </AccessorDecl>}</AccessorBlock></PatternBinding></VariableDecl></MemberDeclListItem><MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>a</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><AccessorBlock>{}</AccessorBlock></PatternBinding></VariableDecl></MemberDeclListItem>
}</MemberDeclBlock></ProtocolDecl><ClassDecl><DeclModifier>

private </DeclModifier><DeclModifier>final </DeclModifier>class D <MemberDeclBlock>{<MemberDeclListItem><VariableDecl><Attribute>
  @objc</Attribute><DeclModifier>
  static </DeclModifier><DeclModifier>private </DeclModifier>var <PatternBinding><IdentifierPattern>a</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><InitializerClause>= <IntegerLiteralExpr>3 </IntegerLiteralExpr></InitializerClause><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>3 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock>, </PatternBinding><PatternBinding><IdentifierPattern>b</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></TypeAnnotation>, </PatternBinding><PatternBinding><IdentifierPattern>c </IdentifierPattern><InitializerClause>= <IntegerLiteralExpr>4</IntegerLiteralExpr></InitializerClause>, </PatternBinding><PatternBinding><IdentifierPattern>d </IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><AccessorBlock>{ <AccessorDecl>get <CodeBlock>{} </CodeBlock></AccessorDecl><AccessorDecl>get <CodeBlock>{}</CodeBlock></AccessorDecl>}</AccessorBlock>, </PatternBinding><PatternBinding><TuplePattern>(<TuplePatternElement><IdentifierPattern>a</IdentifierPattern>, </TuplePatternElement><TuplePatternElement><IdentifierPattern>b</IdentifierPattern></TuplePatternElement>)</TuplePattern><TypeAnnotation>: <TupleType>(<TupleTypeElement><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></TupleTypeElement>)</TupleType></TypeAnnotation></PatternBinding></VariableDecl></MemberDeclListItem><MemberDeclListItem><VariableDecl>
  let <PatternBinding><TuplePattern>(<TuplePatternElement><IdentifierPattern>a</IdentifierPattern>, </TuplePatternElement><TuplePatternElement><IdentifierPattern>b</IdentifierPattern></TuplePatternElement>) </TuplePattern><InitializerClause>= <TupleExpr>(<TupleExprElement><IntegerLiteralExpr>1</IntegerLiteralExpr>,</TupleExprElement><TupleExprElement><IntegerLiteralExpr>2</IntegerLiteralExpr></TupleExprElement>)</TupleExpr></InitializerClause>, </PatternBinding><PatternBinding><WildcardPattern>_ </WildcardPattern><InitializerClause>= <IntegerLiteralExpr>4 </IntegerLiteralExpr></InitializerClause><AccessorBlock>{}</AccessorBlock></PatternBinding></VariableDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>

  func patternTests<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<ForInStmt>
    for <ValueBindingPattern>let <TuplePattern>(<TuplePatternElement><IdentifierPattern>x</IdentifierPattern>, </TuplePatternElement><TuplePatternElement><WildcardPattern>_</WildcardPattern></TuplePatternElement>) </TuplePattern></ValueBindingPattern>in <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr><CodeBlock>{}</CodeBlock></ForInStmt><ForInStmt>
    for <ValueBindingPattern>var <IdentifierPattern>x</IdentifierPattern></ValueBindingPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation>in <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr><CodeBlock>{}</CodeBlock></ForInStmt>
  }</CodeBlock></FunctionDecl></MemberDeclListItem>
}</MemberDeclBlock></ClassDecl><DoStmt>

do <CodeBlock>{<SwitchStmt>
  switch <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr>{<SwitchCase><SwitchCaseLabel>
    case <CaseItem><ValueBindingPattern>let <IdentifierPattern>a</IdentifierPattern></ValueBindingPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ValueBindingPattern>let <ExpressionPattern><SequenceExpr><UnresolvedPatternExpr><IdentifierPattern>a </IdentifierPattern></UnresolvedPatternExpr><AsExpr>as <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></AsExpr></SequenceExpr></ExpressionPattern></ValueBindingPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ValueBindingPattern>let <ExpressionPattern><TupleExpr>(<TupleExprElement><UnresolvedPatternExpr><IdentifierPattern>a</IdentifierPattern></UnresolvedPatternExpr>, </TupleExprElement><TupleExprElement><UnresolvedPatternExpr><IdentifierPattern>b</IdentifierPattern></UnresolvedPatternExpr></TupleExprElement>)</TupleExpr></ExpressionPattern></ValueBindingPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ExpressionPattern><TupleExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>a</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr>, </TupleExprElement><TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>var <IdentifierPattern>b</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr></TupleExprElement>)</TupleExpr></ExpressionPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><IsTypePattern>is <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></IsTypePattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ValueBindingPattern>let <ExpressionPattern><FunctionCallExpr><MemberAccessExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>(<TupleExprElement><UnresolvedPatternExpr><IdentifierPattern>x</IdentifierPattern></UnresolvedPatternExpr></TupleExprElement>)</FunctionCallExpr></ExpressionPattern></ValueBindingPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ExpressionPattern><MemberAccessExpr><IdentifierExpr><DeclNameRef>MyEnum</DeclNameRef></IdentifierExpr>.<DeclNameRef>foo</DeclNameRef></MemberAccessExpr></ExpressionPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ValueBindingPattern>let <ExpressionPattern><SequenceExpr><UnresolvedPatternExpr><IdentifierPattern>a </IdentifierPattern></UnresolvedPatternExpr><AsExpr>as <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></AsExpr></SequenceExpr></ExpressionPattern></ValueBindingPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ValueBindingPattern>let <ExpressionPattern><OptionalChainingExpr><UnresolvedPatternExpr><IdentifierPattern>a</IdentifierPattern></UnresolvedPatternExpr>?</OptionalChainingExpr></ExpressionPattern></ValueBindingPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase>
  }</SwitchStmt>
}</CodeBlock></DoStmt><FunctionDecl>

func statementTests<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<DoStmt>
  do <CodeBlock>{
  } </CodeBlock><CatchClause>catch <CatchItem><ExpressionPattern><TupleExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>var <IdentifierPattern>x</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr>, </TupleExprElement><TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>y</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr></TupleExprElement>) </TupleExpr></ExpressionPattern></CatchItem><CodeBlock>{
  } </CodeBlock></CatchClause><CatchClause>catch <CatchItem><WhereClause>where <BooleanLiteralExpr>false </BooleanLiteralExpr></WhereClause></CatchItem><CodeBlock>{
  } </CodeBlock></CatchClause><CatchClause>catch <CatchItem><ValueBindingPattern>let <IdentifierPattern>e </IdentifierPattern></ValueBindingPattern><WhereClause>where <SequenceExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>e</DeclNameRef></IdentifierExpr>.<DeclNameRef>foo </DeclNameRef></MemberAccessExpr><BinaryOperatorExpr>== </BinaryOperatorExpr><IdentifierExpr><DeclNameRef>bar </DeclNameRef></IdentifierExpr></SequenceExpr></WhereClause></CatchItem><CodeBlock>{
  } </CodeBlock></CatchClause><CatchClause>catch <CatchItem><ExpressionPattern><FunctionCallExpr><MemberAccessExpr>.<DeclNameRef>a</DeclNameRef></MemberAccessExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>a</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr></TupleExprElement>)</FunctionCallExpr></ExpressionPattern>, </CatchItem><CatchItem><ExpressionPattern><FunctionCallExpr><MemberAccessExpr>.<DeclNameRef>b</DeclNameRef></MemberAccessExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>b</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr></TupleExprElement>) </FunctionCallExpr></ExpressionPattern><WhereClause>where <SequenceExpr><IdentifierExpr><DeclNameRef>b </DeclNameRef></IdentifierExpr><BinaryOperatorExpr>== </BinaryOperatorExpr><StringLiteralExpr>"<StringSegment></StringSegment>" </StringLiteralExpr></SequenceExpr></WhereClause></CatchItem><CodeBlock>{
  } </CodeBlock></CatchClause><CatchClause>catch <CatchItem></CatchItem><CodeBlock>{
  }</CodeBlock></CatchClause></DoStmt><RepeatWhileStmt>
  repeat <CodeBlock>{ } </CodeBlock>while <BooleanLiteralExpr>true</BooleanLiteralExpr></RepeatWhileStmt><RepeatWhileStmt>
  LABEL: repeat <CodeBlock>{ } </CodeBlock>while <BooleanLiteralExpr>false</BooleanLiteralExpr></RepeatWhileStmt><WhileStmt>
  while <ConditionElement><BooleanLiteralExpr>true </BooleanLiteralExpr></ConditionElement><CodeBlock>{ }</CodeBlock></WhileStmt><WhileStmt>
  LABEL: while <ConditionElement><BooleanLiteralExpr>true </BooleanLiteralExpr></ConditionElement><CodeBlock>{ }</CodeBlock></WhileStmt><DoStmt>
  LABEL: do <CodeBlock>{}</CodeBlock></DoStmt><SwitchStmt>
  LABEL: switch <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr>{<SwitchCase><SwitchCaseLabel>
    case <CaseItem><ExpressionPattern><IntegerLiteralExpr>1</IntegerLiteralExpr></ExpressionPattern></CaseItem>:</SwitchCaseLabel><FallthroughStmt>
      fallthrough</FallthroughStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ExpressionPattern><IntegerLiteralExpr>2</IntegerLiteralExpr></ExpressionPattern></CaseItem>:</SwitchCaseLabel><BreakStmt>
      break LABEL</BreakStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ExpressionPattern><IntegerLiteralExpr>3</IntegerLiteralExpr></ExpressionPattern></CaseItem>:</SwitchCaseLabel><BreakStmt>
      break</BreakStmt></SwitchCase>
  }</SwitchStmt><ForInStmt>

  for <IdentifierPattern>a </IdentifierPattern>in <IdentifierExpr><DeclNameRef>b </DeclNameRef></IdentifierExpr><CodeBlock>{<DeferStmt>
    defer <CodeBlock>{ <TupleExpr>() </TupleExpr>}</CodeBlock></DeferStmt><IfStmt>
    if <ConditionElement><IdentifierExpr><DeclNameRef>c </DeclNameRef></IdentifierExpr></ConditionElement><CodeBlock>{<ThrowStmt>
      throw <FunctionCallExpr><IdentifierExpr><DeclNameRef>MyError</DeclNameRef></IdentifierExpr>()</FunctionCallExpr></ThrowStmt><ContinueStmt>
      continue</ContinueStmt>
    } </CodeBlock>else <CodeBlock>{<ContinueStmt>
      continue LABEL</ContinueStmt>
    }</CodeBlock></IfStmt>
  }</CodeBlock></ForInStmt><IfStmt>

  if<ConditionElement><IdentifierExpr><DeclNameRef>
    foo</DeclNameRef></IdentifierExpr>,</ConditionElement><ConditionElement><OptionalBindingCondition>
    let <IdentifierPattern>a </IdentifierPattern><InitializerClause>= <IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr></InitializerClause></OptionalBindingCondition>,</ConditionElement><ConditionElement><OptionalBindingCondition>
    let <IdentifierPattern>b</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><InitializerClause>= <IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr></InitializerClause></OptionalBindingCondition>,</ConditionElement><ConditionElement><OptionalBindingCondition>
    var <IdentifierPattern>c </IdentifierPattern><InitializerClause>= <IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr></InitializerClause></OptionalBindingCondition>,</ConditionElement><ConditionElement><MatchingPatternCondition>
    case <ExpressionPattern><TupleExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>v</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr>, </TupleExprElement><TupleExprElement><DiscardAssignmentExpr>_</DiscardAssignmentExpr></TupleExprElement>) </TupleExpr></ExpressionPattern><InitializerClause>= <IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr></InitializerClause></MatchingPatternCondition>,</ConditionElement><ConditionElement><MatchingPatternCondition>
    case <ExpressionPattern><TupleExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>v</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr>, </TupleExprElement><TupleExprElement><DiscardAssignmentExpr>_</DiscardAssignmentExpr></TupleExprElement>)</TupleExpr></ExpressionPattern><TypeAnnotation>: <TupleType>(<TupleTypeElement><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></TupleTypeElement>) </TupleType></TypeAnnotation><InitializerClause>= <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr></InitializerClause></MatchingPatternCondition></ConditionElement><CodeBlock>{
  } </CodeBlock>else <IfStmt>if <ConditionElement><IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr></ConditionElement><CodeBlock>{
  } </CodeBlock>else <CodeBlock>{
  }</CodeBlock></IfStmt></IfStmt><GuardStmt>

  guard <ConditionElement><OptionalBindingCondition>let <IdentifierPattern>a </IdentifierPattern><InitializerClause>= <IdentifierExpr><DeclNameRef>b </DeclNameRef></IdentifierExpr></InitializerClause></OptionalBindingCondition></ConditionElement>else <CodeBlock>{}</CodeBlock></GuardStmt><GuardStmt>

  guard <ConditionElement><OptionalBindingCondition>let <IdentifierPattern>self </IdentifierPattern><InitializerClause>= <IdentifierExpr><DeclNameRef>self </DeclNameRef></IdentifierExpr></InitializerClause></OptionalBindingCondition></ConditionElement>else <CodeBlock>{}</CodeBlock></GuardStmt><ForInStmt>

  for <ValueBindingPattern>var <IdentifierPattern>i </IdentifierPattern></ValueBindingPattern>in <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr><WhereClause>where <MemberAccessExpr><IdentifierExpr><DeclNameRef>i</DeclNameRef></IdentifierExpr>.<DeclNameRef>foo </DeclNameRef></MemberAccessExpr></WhereClause><CodeBlock>{}</CodeBlock></ForInStmt><ForInStmt>
  for case <IsTypePattern>is <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></IsTypePattern>in <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr><CodeBlock>{}</CodeBlock></ForInStmt><SwitchStmt>

  switch <IdentifierExpr><DeclNameRef>Foo </DeclNameRef></IdentifierExpr>{<SwitchCase><SwitchCaseLabel>
    case <CaseItem><ExpressionPattern><IdentifierExpr><DeclNameRef>n1</DeclNameRef></IdentifierExpr></ExpressionPattern></CaseItem>:</SwitchCaseLabel><BreakStmt>
      break</BreakStmt></SwitchCase><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ExpressionPattern><IdentifierExpr><DeclNameRef>n2</DeclNameRef></IdentifierExpr></ExpressionPattern>, </CaseItem><CaseItem><ExpressionPattern><IdentifierExpr><DeclNameRef>n3l</DeclNameRef></IdentifierExpr></ExpressionPattern></CaseItem>:</SwitchCaseLabel><BreakStmt>
      break</BreakStmt></SwitchCase><IfConfigDecl><IfConfigClause>
#if <IdentifierExpr><DeclNameRef>FOO</DeclNameRef></IdentifierExpr><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ValueBindingPattern>let <ExpressionPattern><TupleExpr>(<TupleExprElement><UnresolvedPatternExpr><IdentifierPattern>x</IdentifierPattern></UnresolvedPatternExpr>, </TupleExprElement><TupleExprElement><UnresolvedPatternExpr><IdentifierPattern>y</IdentifierPattern></UnresolvedPatternExpr></TupleExprElement>)  </TupleExpr></ExpressionPattern></ValueBindingPattern><WhereClause>where <PrefixOperatorExpr>!<IdentifierExpr><DeclNameRef>x</DeclNameRef></IdentifierExpr></PrefixOperatorExpr></WhereClause>, </CaseItem><CaseItem><ExpressionPattern><IdentifierExpr><DeclNameRef>n3l </DeclNameRef></IdentifierExpr></ExpressionPattern><WhereClause>where <BooleanLiteralExpr>false</BooleanLiteralExpr></WhereClause></CaseItem>:</SwitchCaseLabel><BreakStmt>
      break</BreakStmt></SwitchCase></IfConfigClause><IfConfigClause>
#elseif <IdentifierExpr><DeclNameRef>BAR</DeclNameRef></IdentifierExpr><SwitchCase><SwitchCaseLabel>
    case <CaseItem><ValueBindingPattern>let <IdentifierPattern>y</IdentifierPattern></ValueBindingPattern></CaseItem>:</SwitchCaseLabel><BreakStmt>
      break</BreakStmt></SwitchCase></IfConfigClause><IfConfigClause>
#else<SwitchCase><SwitchCaseLabel>
    case <CaseItem><ExpressionPattern><FunctionCallExpr><MemberAccessExpr>.<DeclNameRef>foo</DeclNameRef></MemberAccessExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>x</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr></TupleExprElement>)</FunctionCallExpr></ExpressionPattern></CaseItem>:</SwitchCaseLabel><BreakStmt>
      break</BreakStmt></SwitchCase></IfConfigClause>
#endif</IfConfigDecl><SwitchCase><SwitchDefaultLabel>
    default:</SwitchDefaultLabel><BreakStmt>
      break</BreakStmt></SwitchCase>
  }</SwitchStmt><SwitchStmt>

  switch <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr>{<SwitchCase><SwitchCaseLabel>
  case <CaseItem><ExpressionPattern><IntegerLiteralExpr>1</IntegerLiteralExpr></ExpressionPattern>, </CaseItem><CaseItem><ExpressionPattern><IntegerLiteralExpr>2</IntegerLiteralExpr></ExpressionPattern>, </CaseItem><CaseItem><ExpressionPattern><IntegerLiteralExpr>3</IntegerLiteralExpr></ExpressionPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><SwitchDefaultLabel>
  default: </SwitchDefaultLabel><BreakStmt>break</BreakStmt></SwitchCase>
  }</SwitchStmt><SwitchStmt>

  switch <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr>{<SwitchCase><SwitchCaseLabel>
  case <CaseItem><ExpressionPattern><IntegerLiteralExpr>1</IntegerLiteralExpr></ExpressionPattern>, </CaseItem><CaseItem><ExpressionPattern><IntegerLiteralExpr>2</IntegerLiteralExpr></ExpressionPattern>, </CaseItem><CaseItem><ExpressionPattern><IntegerLiteralExpr>3</IntegerLiteralExpr></ExpressionPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><Attribute>
  @unknown </Attribute><SwitchDefaultLabel>default: </SwitchDefaultLabel><BreakStmt>break</BreakStmt></SwitchCase>
  }</SwitchStmt><SwitchStmt>

  switch <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr>{<SwitchCase><SwitchCaseLabel>
  case <CaseItem><ExpressionPattern><IntegerLiteralExpr>1</IntegerLiteralExpr></ExpressionPattern>, </CaseItem><CaseItem><ExpressionPattern><IntegerLiteralExpr>2</IntegerLiteralExpr></ExpressionPattern>, </CaseItem><CaseItem><ExpressionPattern><IntegerLiteralExpr>3</IntegerLiteralExpr></ExpressionPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><Attribute>
  @unknown </Attribute><SwitchCaseLabel>case <CaseItem><ExpressionPattern><DiscardAssignmentExpr>_</DiscardAssignmentExpr></ExpressionPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase>
  }</SwitchStmt><SwitchStmt>

  switch <IdentifierExpr><DeclNameRef>foo </DeclNameRef></IdentifierExpr>{<SwitchCase><SwitchCaseLabel>
  case <CaseItem><ExpressionPattern><IntegerLiteralExpr>1</IntegerLiteralExpr></ExpressionPattern>, </CaseItem><CaseItem><ExpressionPattern><IntegerLiteralExpr>2</IntegerLiteralExpr></ExpressionPattern>, </CaseItem><CaseItem><ExpressionPattern><IntegerLiteralExpr>3</IntegerLiteralExpr></ExpressionPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><Attribute>
  // This is rejected in Sema, but should be preserved by Syntax.
  @unknown </Attribute><SwitchCaseLabel>case <CaseItem><ExpressionPattern><TupleExpr>(<TupleExprElement><IntegerLiteralExpr>42</IntegerLiteralExpr>, </TupleExprElement><TupleExprElement><PrefixOperatorExpr>-<IntegerLiteralExpr>42</IntegerLiteralExpr></PrefixOperatorExpr></TupleExprElement>) </TupleExpr></ExpressionPattern><WhereClause>where <SequenceExpr><IntegerLiteralExpr>1 </IntegerLiteralExpr><BinaryOperatorExpr>== </BinaryOperatorExpr><IntegerLiteralExpr>2</IntegerLiteralExpr></SequenceExpr></WhereClause></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><Attribute>
  @garbage </Attribute><SwitchCaseLabel>case <CaseItem><ExpressionPattern><IntegerLiteralExpr>0</IntegerLiteralExpr></ExpressionPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase><SwitchCase><Attribute>
  @garbage(foobar) </Attribute><SwitchCaseLabel>case <CaseItem><ExpressionPattern><PrefixOperatorExpr>-<IntegerLiteralExpr>1</IntegerLiteralExpr></PrefixOperatorExpr></ExpressionPattern></CaseItem>: </SwitchCaseLabel><BreakStmt>break</BreakStmt></SwitchCase>
  }</SwitchStmt>
}</CodeBlock></FunctionDecl><ExtensionDecl>

// MARK: - ExtensionDecl

extension <SimpleTypeIdentifier><DeclNameRef>ext </DeclNameRef></SimpleTypeIdentifier><MemberDeclBlock>{<MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>s</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><CodeBlock>{<ReturnStmt>
    return <IntegerLiteralExpr>42</IntegerLiteralExpr></ReturnStmt>
  }</CodeBlock></PatternBinding></VariableDecl></MemberDeclListItem>
}</MemberDeclBlock></ExtensionDecl><ExtensionDecl><Attribute>

@available(<AvailabilityArgument>*, </AvailabilityArgument><AvailabilityArgument>unavailable</AvailabilityArgument>)</Attribute><DeclModifier>
fileprivate </DeclModifier>extension <SimpleTypeIdentifier><DeclNameRef>ext </DeclNameRef></SimpleTypeIdentifier><MemberDeclBlock>{}</MemberDeclBlock></ExtensionDecl><ExtensionDecl>

extension <SimpleTypeIdentifier><DeclNameRef>ext </DeclNameRef></SimpleTypeIdentifier><TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>extProtocol </DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause><MemberDeclBlock>{}</MemberDeclBlock></ExtensionDecl><ExtensionDecl>

extension <SimpleTypeIdentifier><DeclNameRef>ext </DeclNameRef></SimpleTypeIdentifier><GenericWhereClause>where <GenericRequirement><SameTypeRequirement><SimpleTypeIdentifier><DeclNameRef>A </DeclNameRef></SimpleTypeIdentifier>== <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></SameTypeRequirement>, </GenericRequirement><GenericRequirement><ConformanceRequirement><SimpleTypeIdentifier><DeclNameRef>B</DeclNameRef></SimpleTypeIdentifier>: <SimpleTypeIdentifier><DeclNameRef>Numeric </DeclNameRef></SimpleTypeIdentifier></ConformanceRequirement></GenericRequirement></GenericWhereClause><MemberDeclBlock>{}</MemberDeclBlock></ExtensionDecl><ExtensionDecl>

extension <MemberTypeIdentifier><MemberTypeIdentifier><SimpleTypeIdentifier><DeclNameRef>ext</DeclNameRef></SimpleTypeIdentifier>.<DeclNameRef>a</DeclNameRef></MemberTypeIdentifier>.<DeclNameRef>b </DeclNameRef></MemberTypeIdentifier><MemberDeclBlock>{}</MemberDeclBlock></ExtensionDecl><FunctionDecl>

func foo<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<VariableDecl>
  var <PatternBinding><IdentifierPattern>a </IdentifierPattern><InitializerClause>= <StringLiteralExpr>"<StringSegment>abc </StringSegment><ExpressionSegment>\(<TupleExprElement><FunctionCallExpr><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr></TupleExprElement>)</ExpressionSegment><StringSegment> def </StringSegment><ExpressionSegment>\(<TupleExprElement><SequenceExpr><IdentifierExpr><DeclNameRef>a </DeclNameRef></IdentifierExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><IdentifierExpr><DeclNameRef>b </DeclNameRef></IdentifierExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><StringLiteralExpr>"<StringSegment>a </StringSegment><ExpressionSegment>\(<TupleExprElement><IntegerLiteralExpr>3</IntegerLiteralExpr></TupleExprElement>)</ExpressionSegment><StringSegment></StringSegment>"</StringLiteralExpr></SequenceExpr></TupleExprElement>)</ExpressionSegment><StringSegment> gh </StringSegment><ExpressionSegment>\(<TupleExprElement><IdentifierExpr><DeclNameRef>bar</DeclNameRef></IdentifierExpr>, </TupleExprElement><TupleExprElement>default: <IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</ExpressionSegment><StringSegment></StringSegment>"</StringLiteralExpr></InitializerClause></PatternBinding></VariableDecl><VariableDecl>
  var <PatternBinding><IdentifierPattern>a </IdentifierPattern><InitializerClause>= <StringLiteralExpr>"""<StringSegment>
  abc </StringSegment><ExpressionSegment>\( <TupleExprElement><SequenceExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr>() </FunctionCallExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>bar</DeclNameRef></IdentifierExpr>() </FunctionCallExpr></SequenceExpr></TupleExprElement>)</ExpressionSegment><StringSegment>
  de </StringSegment><ExpressionSegment>\(<TupleExprElement><SequenceExpr><IntegerLiteralExpr>3 </IntegerLiteralExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><IntegerLiteralExpr>3 </IntegerLiteralExpr><BinaryOperatorExpr>+ </BinaryOperatorExpr><StringLiteralExpr>"<StringSegment>abc </StringSegment><ExpressionSegment>\(<TupleExprElement><FunctionCallExpr><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr></TupleExprElement>)</ExpressionSegment><StringSegment> def</StringSegment>"</StringLiteralExpr></SequenceExpr></TupleExprElement>)</ExpressionSegment><StringSegment>
  fg
  </StringSegment><ExpressionSegment>\(<TupleExprElement><IdentifierExpr><DeclNameRef>bar</DeclNameRef></IdentifierExpr>, </TupleExprElement><TupleExprElement>default: <IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>)</ExpressionSegment><StringSegment>
  </StringSegment>"""</StringLiteralExpr></InitializerClause></PatternBinding></VariableDecl>
}</CodeBlock></FunctionDecl><FunctionDecl>

func keypath<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><KeyPathExpr>\<IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr><MemberAccessExpr><OptionalChainingExpr><KeyPathBaseExpr>.</KeyPathBaseExpr>?</OptionalChainingExpr>.<DeclNameRef>b</DeclNameRef></MemberAccessExpr></KeyPathExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><KeyPathExpr>\<MemberAccessExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr>.<DeclNameRef>b</DeclNameRef></MemberAccessExpr>.<DeclNameRef>c</DeclNameRef></MemberAccessExpr></KeyPathExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><KeyPathExpr>\<SubscriptExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr>.<DeclNameRef>b</DeclNameRef></MemberAccessExpr>[<TupleExprElement><IntegerLiteralExpr>1</IntegerLiteralExpr></TupleExprElement>]</SubscriptExpr></KeyPathExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><KeyPathExpr>\<MemberAccessExpr><MemberAccessExpr>.<DeclNameRef>a</DeclNameRef></MemberAccessExpr>.<DeclNameRef>b</DeclNameRef></MemberAccessExpr></KeyPathExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><KeyPathExpr>\<SpecializeExpr><IdentifierExpr><DeclNameRef>Array</DeclNameRef></IdentifierExpr><GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></SpecializeExpr><SubscriptExpr><KeyPathBaseExpr>.</KeyPathBaseExpr>[]</SubscriptExpr></KeyPathExpr></SequenceExpr><SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ObjcKeyPathExpr>#keyPath(<ObjcNamePiece><DeclNameRef>a</DeclNameRef>.</ObjcNamePiece><ObjcNamePiece><DeclNameRef>b</DeclNameRef>.</ObjcNamePiece><ObjcNamePiece><DeclNameRef>c</DeclNameRef></ObjcNamePiece>)</ObjcKeyPathExpr></SequenceExpr>
}</CodeBlock></FunctionDecl><FunctionDecl>
func objcSelector<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<SequenceExpr><DiscardAssignmentExpr>
  _ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><ArrayExpr>[<ArrayElement><ObjcSelectorExpr>
    #selector(getter: <MemberAccessExpr><IdentifierExpr><DeclNameRef>Foo</DeclNameRef></IdentifierExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>)</ObjcSelectorExpr>,</ArrayElement><ArrayElement><ObjcSelectorExpr>
    #selector(setter: <MemberAccessExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>Foo</DeclNameRef></IdentifierExpr>.<DeclNameRef>Bar</DeclNameRef></MemberAccessExpr>.<DeclNameRef>baz</DeclNameRef></MemberAccessExpr>)</ObjcSelectorExpr>,</ArrayElement><ArrayElement><ObjcSelectorExpr>
    #selector(<MemberAccessExpr><IdentifierExpr><DeclNameRef>Foo</DeclNameRef></IdentifierExpr>.<DeclNameRef>method<DeclNameArguments>(<DeclNameArgument>x:</DeclNameArgument><DeclNameArgument>y:</DeclNameArgument>)</DeclNameArguments></DeclNameRef></MemberAccessExpr>)</ObjcSelectorExpr>,</ArrayElement><ArrayElement><ObjcSelectorExpr>
    #selector(<FunctionCallExpr><MemberAccessExpr><SubscriptExpr><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr>[<TupleExprElement><IntegerLiteralExpr>42</IntegerLiteralExpr></TupleExprElement>]</SubscriptExpr>.<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>(<TupleExprElement><IdentifierExpr><DeclNameRef>x</DeclNameRef></IdentifierExpr></TupleExprElement>)</FunctionCallExpr>)</ObjcSelectorExpr>,</ArrayElement><ArrayElement><ObjcSelectorExpr>
    #selector(<ClosureExpr>{ <ClosureSignature><ClosureCaptureSignature>[<ClosureCaptureItem><IdentifierExpr><DeclNameRef>x</DeclNameRef></IdentifierExpr></ClosureCaptureItem>] </ClosureCaptureSignature>in </ClosureSignature><ReturnStmt>return <NilLiteralExpr>nil </NilLiteralExpr></ReturnStmt>}</ClosureExpr>)</ObjcSelectorExpr></ArrayElement>
  ]</ArrayExpr></SequenceExpr>
}</CodeBlock></FunctionDecl><FunctionDecl>

func objectLiterals<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<ObjectLiteralExpr>
  #fileLiteral(<TupleExprElement><IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr></TupleExprElement>)</ObjectLiteralExpr><ObjectLiteralExpr>
  #colorLiteral(<TupleExprElement><IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr>, </TupleExprElement><TupleExprElement><IdentifierExpr><DeclNameRef>b</DeclNameRef></IdentifierExpr></TupleExprElement>)</ObjectLiteralExpr><ObjectLiteralExpr>
  #imageLiteral(<TupleExprElement><IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr>, </TupleExprElement><TupleExprElement><IdentifierExpr><DeclNameRef>b</DeclNameRef></IdentifierExpr>, </TupleExprElement><TupleExprElement><IdentifierExpr><DeclNameRef>c</DeclNameRef></IdentifierExpr></TupleExprElement>)</ObjectLiteralExpr><PoundColumnExpr>
  #column</PoundColumnExpr><PoundFileExpr>
  #file</PoundFileExpr><PoundFunctionExpr>
  #function</PoundFunctionExpr><PoundDsohandleExpr>
  #dsohandle</PoundDsohandleExpr>
}</CodeBlock></FunctionDecl><EnumDecl>

enum E1 <TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>String </DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause><MemberDeclBlock>{<MemberDeclListItem><EnumCaseDecl>
  case <EnumCaseElement>foo <InitializerClause>= <IntegerLiteralExpr>1</IntegerLiteralExpr></InitializerClause></EnumCaseElement></EnumCaseDecl></MemberDeclListItem><MemberDeclListItem><EnumCaseDecl>
  case <EnumCaseElement>bar <InitializerClause>= <StringLiteralExpr>"<StringSegment>test</StringSegment>"</StringLiteralExpr></InitializerClause>, </EnumCaseElement><EnumCaseElement>baz<ParameterClause>(<FunctionParameter>x: <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter><SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><InitializerClause>= <IntegerLiteralExpr>12</IntegerLiteralExpr></InitializerClause></EnumCaseElement></EnumCaseDecl></MemberDeclListItem><MemberDeclListItem><EnumCaseDecl><DeclModifier>
  indirect </DeclModifier>case <EnumCaseElement>qux<ParameterClause>(<FunctionParameter><SimpleTypeIdentifier><DeclNameRef>E1</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>)</ParameterClause></EnumCaseElement></EnumCaseDecl></MemberDeclListItem><MemberDeclListItem><EnumDecl><DeclModifier>

  indirect </DeclModifier><DeclModifier>private </DeclModifier>enum E2<GenericParameterClause><<GenericParameter>T</GenericParameter>></GenericParameterClause><TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>String </DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause><GenericWhereClause>where <GenericRequirement><ConformanceRequirement><SimpleTypeIdentifier><DeclNameRef>T</DeclNameRef></SimpleTypeIdentifier>: <SimpleTypeIdentifier><DeclNameRef>SomeProtocol </DeclNameRef></SimpleTypeIdentifier></ConformanceRequirement></GenericRequirement></GenericWhereClause><MemberDeclBlock>{<MemberDeclListItem><EnumCaseDecl>
    case <EnumCaseElement>foo, </EnumCaseElement><EnumCaseElement>bar, </EnumCaseElement><EnumCaseElement>baz</EnumCaseElement></EnumCaseDecl></MemberDeclListItem>
  }</MemberDeclBlock></EnumDecl></MemberDeclListItem>
}</MemberDeclBlock></EnumDecl><PrecedenceGroupDecl>

precedencegroup FooPrecedence {<PrecedenceGroupRelation>
  higherThan: <PrecedenceGroupNameElement><DeclNameRef>DefaultPrecedence</DeclNameRef>, </PrecedenceGroupNameElement><PrecedenceGroupNameElement><DeclNameRef>UnknownPrecedence</DeclNameRef></PrecedenceGroupNameElement></PrecedenceGroupRelation><PrecedenceGroupAssignment>
  assignment: false</PrecedenceGroupAssignment><PrecedenceGroupAssociativity>
  associativity: none</PrecedenceGroupAssociativity>
}</PrecedenceGroupDecl><PrecedenceGroupDecl>
precedencegroup BarPrecedence {}</PrecedenceGroupDecl><PrecedenceGroupDecl>
precedencegroup BazPrecedence {<PrecedenceGroupAssociativity>
  associativity: left</PrecedenceGroupAssociativity><PrecedenceGroupAssignment>
  assignment: true</PrecedenceGroupAssignment><PrecedenceGroupAssociativity>
  associativity: right</PrecedenceGroupAssociativity><PrecedenceGroupRelation>
  lowerThan: <PrecedenceGroupNameElement><DeclNameRef>DefaultPrecedence</DeclNameRef></PrecedenceGroupNameElement></PrecedenceGroupRelation>
}</PrecedenceGroupDecl><OperatorDecl><DeclModifier>

infix </DeclModifier>operator<++><OperatorPrecedenceAndTypes>:<PrecedenceGroupNameElement><DeclNameRef>FooPrecedence</DeclNameRef></PrecedenceGroupNameElement></OperatorPrecedenceAndTypes></OperatorDecl><OperatorDecl><DeclModifier>
prefix </DeclModifier>operator..<<</OperatorDecl><OperatorDecl><DeclModifier>
postfix </DeclModifier>operator <-</OperatorDecl><FunctionDecl>

func higherOrderFunc<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<VariableDecl>
  let <PatternBinding><IdentifierPattern>x </IdentifierPattern><InitializerClause>= <ArrayExpr>[<ArrayElement><IntegerLiteralExpr>1</IntegerLiteralExpr>,</ArrayElement><ArrayElement><IntegerLiteralExpr>2</IntegerLiteralExpr>,</ArrayElement><ArrayElement><IntegerLiteralExpr>3</IntegerLiteralExpr></ArrayElement>]</ArrayExpr></InitializerClause></PatternBinding></VariableDecl><FunctionCallExpr><MemberAccessExpr><IdentifierExpr><DeclNameRef>
  x</DeclNameRef></IdentifierExpr>.<DeclNameRef>reduce</DeclNameRef></MemberAccessExpr>(<TupleExprElement><IntegerLiteralExpr>0</IntegerLiteralExpr>, </TupleExprElement><TupleExprElement><IdentifierExpr><DeclNameRef>+</DeclNameRef></IdentifierExpr></TupleExprElement>)</FunctionCallExpr>
}</CodeBlock></FunctionDecl><IfStmt>

if <ConditionElement><AvailabilityCondition>#available(<AvailabilityArgument><AvailabilityVersionRestriction>iOS <VersionTuple>11</VersionTuple></AvailabilityVersionRestriction>, </AvailabilityArgument><AvailabilityArgument><AvailabilityVersionRestriction>macOS <VersionTuple>10.11.2</VersionTuple></AvailabilityVersionRestriction>, </AvailabilityArgument><AvailabilityArgument>*</AvailabilityArgument>) </AvailabilityCondition></ConditionElement><CodeBlock>{}</CodeBlock></IfStmt><FunctionDecl><Attribute>

@_specialize(<GenericWhereClause>where <GenericRequirement><SameTypeRequirement><SimpleTypeIdentifier><DeclNameRef>T </DeclNameRef></SimpleTypeIdentifier>== <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></SameTypeRequirement></GenericRequirement></GenericWhereClause>)</Attribute><Attribute>
@_specialize(<LabeledSpecializeEntry>exported: true, </LabeledSpecializeEntry><GenericWhereClause>where <GenericRequirement><SameTypeRequirement><SimpleTypeIdentifier><DeclNameRef>T </DeclNameRef></SimpleTypeIdentifier>== <SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier></SameTypeRequirement></GenericRequirement></GenericWhereClause>)</Attribute><DeclModifier>
public </DeclModifier>func specializedGenericFunc<GenericParameterClause><<GenericParameter>T</GenericParameter>></GenericParameterClause><FunctionSignature><ParameterClause>(<FunctionParameter>_ t: <SimpleTypeIdentifier><DeclNameRef>T</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>T </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
  return <IdentifierExpr><DeclNameRef>t</DeclNameRef></IdentifierExpr></ReturnStmt>
}</CodeBlock></FunctionDecl><ProtocolDecl>

protocol Q <MemberDeclBlock>{<MemberDeclListItem><FunctionDecl>
  func g<FunctionSignature><ParameterClause>()</ParameterClause></FunctionSignature></FunctionDecl></MemberDeclListItem><MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>x</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>String </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation><AccessorBlock>{ <AccessorDecl>get </AccessorDecl>}</AccessorBlock></PatternBinding></VariableDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl>
  func f<FunctionSignature><ParameterClause>(<FunctionParameter>x:<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>y:<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature></FunctionDecl></MemberDeclListItem><MemberDeclListItem><IfConfigDecl><IfConfigClause>
  #if <IdentifierExpr><DeclNameRef>FOO_BAR</DeclNameRef></IdentifierExpr><MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>conditionalVar</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier></TypeAnnotation></PatternBinding></VariableDecl></MemberDeclListItem></IfConfigClause>
  #endif</IfConfigDecl></MemberDeclListItem>
}</MemberDeclBlock></ProtocolDecl><StructDecl>

struct S <TypeInheritanceClause>: <InheritedType><SimpleTypeIdentifier><DeclNameRef>Q</DeclNameRef></SimpleTypeIdentifier>, </InheritedType><InheritedType><SimpleTypeIdentifier><DeclNameRef>Equatable </DeclNameRef></SimpleTypeIdentifier></InheritedType></TypeInheritanceClause><MemberDeclBlock>{<MemberDeclListItem><FunctionDecl><Attribute>
  @_implements(<ImplementsAttributeArguments><SimpleTypeIdentifier><DeclNameRef>Q</DeclNameRef></SimpleTypeIdentifier>, <DeclNameRef>f<DeclNameArguments>(<DeclNameArgument>x:</DeclNameArgument><DeclNameArgument>y:</DeclNameArgument>)</DeclNameArguments></DeclNameRef></ImplementsAttributeArguments>)</Attribute>
  func h<FunctionSignature><ParameterClause>(<FunctionParameter>x:<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>y:<SimpleTypeIdentifier><DeclNameRef>Int</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Int </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
    return <IntegerLiteralExpr>6</IntegerLiteralExpr></ReturnStmt>
  }</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl><Attribute>

  @_implements(<ImplementsAttributeArguments><SimpleTypeIdentifier><DeclNameRef>Equatable</DeclNameRef></SimpleTypeIdentifier>, <DeclNameRef>==<DeclNameArguments>(<DeclNameArgument>_:</DeclNameArgument><DeclNameArgument>_:</DeclNameArgument>)</DeclNameArguments></DeclNameRef></ImplementsAttributeArguments>)</Attribute><DeclModifier>
  public </DeclModifier><DeclModifier>static </DeclModifier>func isEqual<FunctionSignature><ParameterClause>(<FunctionParameter>_ lhs: <SimpleTypeIdentifier><DeclNameRef>S</DeclNameRef></SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>_ rhs: <SimpleTypeIdentifier><DeclNameRef>S</DeclNameRef></SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier><DeclNameRef>Bool </DeclNameRef></SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
    return <BooleanLiteralExpr>false</BooleanLiteralExpr></ReturnStmt>
  }</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><VariableDecl><Attribute>

  @_implements(<ImplementsAttributeArguments><SimpleTypeIdentifier><DeclNameRef>P</DeclNameRef></SimpleTypeIdentifier>, <DeclNameRef>x</DeclNameRef></ImplementsAttributeArguments>)</Attribute>
  var <PatternBinding><IdentifierPattern>y</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier></TypeAnnotation></PatternBinding></VariableDecl></MemberDeclListItem><MemberDeclListItem><FunctionDecl><Attribute>
  @_implements(<ImplementsAttributeArguments><SimpleTypeIdentifier><DeclNameRef>P</DeclNameRef></SimpleTypeIdentifier>, <DeclNameRef>g<DeclNameArguments>()</DeclNameArguments></DeclNameRef></ImplementsAttributeArguments>)</Attribute>
  func h<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{ <SequenceExpr><DiscardAssignmentExpr>_ </DiscardAssignmentExpr><AssignmentExpr>= </AssignmentExpr><KeyPathExpr>\<MemberAccessExpr>.self </MemberAccessExpr></KeyPathExpr></SequenceExpr>}</CodeBlock></FunctionDecl></MemberDeclListItem><MemberDeclListItem><VariableDecl><Attribute>

  @available(<AvailabilityArgument>*, </AvailabilityArgument><AvailabilityArgument><AvailabilityLabeledArgument>deprecated: <VersionTuple>1.2</VersionTuple></AvailabilityLabeledArgument>, </AvailabilityArgument><AvailabilityArgument><AvailabilityLabeledArgument>message: "ABC"</AvailabilityLabeledArgument></AvailabilityArgument>)</Attribute><DeclModifier>
  fileprivate(set) </DeclModifier>var <PatternBinding><IdentifierPattern>x</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier></TypeAnnotation></PatternBinding></VariableDecl></MemberDeclListItem>
}</MemberDeclBlock></StructDecl><StructDecl>

struct ReadModify <MemberDeclBlock>{<MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>st0 </IdentifierPattern><InitializerClause>= <TupleExpr>(<TupleExprElement><StringLiteralExpr>"<StringSegment>a</StringSegment>"</StringLiteralExpr>, </TupleExprElement><TupleExprElement><StringLiteralExpr>"<StringSegment>b</StringSegment>"</StringLiteralExpr></TupleExprElement>)</TupleExpr></InitializerClause></PatternBinding></VariableDecl></MemberDeclListItem><MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>rm0</IdentifierPattern><TypeAnnotation>: <TupleType>(<TupleTypeElement><SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement><SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier></TupleTypeElement>) </TupleType></TypeAnnotation><AccessorBlock>{<AccessorDecl>
    _read <CodeBlock>{ <YieldStmt>yield <YieldList>(<TupleExpr>(<TupleExprElement><StringLiteralExpr>"<StringSegment>a</StringSegment>"</StringLiteralExpr>, </TupleExprElement><TupleExprElement><StringLiteralExpr>"<StringSegment>b</StringSegment>"</StringLiteralExpr></TupleExprElement>)</TupleExpr>) </YieldList></YieldStmt>}</CodeBlock></AccessorDecl><AccessorDecl>
    _modify <CodeBlock>{ <YieldStmt>yield <InOutExpr>&<IdentifierExpr><DeclNameRef>st0 </DeclNameRef></IdentifierExpr></InOutExpr></YieldStmt>}</CodeBlock></AccessorDecl>
  }</AccessorBlock></PatternBinding></VariableDecl></MemberDeclListItem><MemberDeclListItem><VariableDecl>
  var <PatternBinding><IdentifierPattern>rm1</IdentifierPattern><TypeAnnotation>: <TupleType>(<TupleTypeElement><SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement><SimpleTypeIdentifier><DeclNameRef>String</DeclNameRef></SimpleTypeIdentifier></TupleTypeElement>) </TupleType></TypeAnnotation><AccessorBlock>{<AccessorDecl>
    _read <CodeBlock>{ <YieldStmt>yield <YieldList>(<IdentifierExpr><DeclNameRef>st0</DeclNameRef></IdentifierExpr>) </YieldList></YieldStmt>}</CodeBlock></AccessorDecl>
  }</AccessorBlock></PatternBinding></VariableDecl></MemberDeclListItem>
}</MemberDeclBlock></StructDecl><StructDecl><CustomAttribute>

@<SimpleTypeIdentifier><DeclNameRef>custom </DeclNameRef></SimpleTypeIdentifier></CustomAttribute><Attribute>@_alignment(16) </Attribute><DeclModifier>public </DeclModifier>struct float3 <MemberDeclBlock>{ <MemberDeclListItem><VariableDecl><DeclModifier>public </DeclModifier>var <PatternBinding><IdentifierPattern>x</IdentifierPattern>, </PatternBinding><PatternBinding><IdentifierPattern>y</IdentifierPattern>, </PatternBinding><PatternBinding><IdentifierPattern>z</IdentifierPattern><TypeAnnotation>: <SimpleTypeIdentifier><DeclNameRef>Float </DeclNameRef></SimpleTypeIdentifier></TypeAnnotation></PatternBinding></VariableDecl></MemberDeclListItem>}</MemberDeclBlock></StructDecl><PoundSourceLocation>

#sourceLocation(<PoundSourceLocationArgs>file: "otherFile.swift", line: 5</PoundSourceLocationArgs>)</PoundSourceLocation><FunctionDecl>

func foo<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl><PoundSourceLocation>

#sourceLocation()</PoundSourceLocation>

"<StringSegment>abc </StringSegment>\( } )<StringSegment> def</StringSegment>"<PoundAssertStmt>

#assert(<BooleanLiteralExpr>true</BooleanLiteralExpr>)</PoundAssertStmt><PoundAssertStmt>
#assert(<BooleanLiteralExpr>false</BooleanLiteralExpr>)</PoundAssertStmt><PoundAssertStmt>
#assert(<BooleanLiteralExpr>true</BooleanLiteralExpr>, "hello world")</PoundAssertStmt><FunctionDecl><DeclModifier>

public </DeclModifier>func anyFoo<FunctionSignature><ParameterClause>() </ParameterClause><ReturnClause>-> <SomeType>some <SimpleTypeIdentifier><DeclNameRef>Foo </DeclNameRef></SimpleTypeIdentifier></SomeType></ReturnClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl><FunctionDecl><DeclModifier>
public </DeclModifier>func qoo<FunctionSignature><ParameterClause>() </ParameterClause><ReturnClause>-> <SomeType>some <CompositionType><CompositionTypeElement><SimpleTypeIdentifier><DeclNameRef>O </DeclNameRef></SimpleTypeIdentifier>& </CompositionTypeElement><CompositionTypeElement><SimpleTypeIdentifier><DeclNameRef>O2 </DeclNameRef></SimpleTypeIdentifier></CompositionTypeElement></CompositionType></SomeType></ReturnClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl><FunctionDecl>
func zlop<FunctionSignature><ParameterClause>() </ParameterClause><ReturnClause>-> <SomeType>some <CompositionType><CompositionTypeElement><SimpleTypeIdentifier><DeclNameRef>C </DeclNameRef></SimpleTypeIdentifier>& </CompositionTypeElement><CompositionTypeElement><SimpleTypeIdentifier><DeclNameRef>AnyObject </DeclNameRef></SimpleTypeIdentifier>& </CompositionTypeElement><CompositionTypeElement><SimpleTypeIdentifier><DeclNameRef>P </DeclNameRef></SimpleTypeIdentifier></CompositionTypeElement></CompositionType></SomeType></ReturnClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl><FunctionDecl><CustomAttribute>

@<SimpleTypeIdentifier><DeclNameRef>custom</DeclNameRef></SimpleTypeIdentifier>(<TupleExprElement><IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr>, </TupleExprElement><TupleExprElement><IdentifierExpr><DeclNameRef>b</DeclNameRef></IdentifierExpr>,</TupleExprElement><TupleExprElement><IdentifierExpr><DeclNameRef>c</DeclNameRef></IdentifierExpr></TupleExprElement>)</CustomAttribute>
func foo<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl><FunctionDecl><CustomAttribute>

@<SimpleTypeIdentifier><DeclNameRef>custom_attr</DeclNameRef></SimpleTypeIdentifier></CustomAttribute><CustomAttribute>
@<SimpleTypeIdentifier><DeclNameRef>custom</DeclNameRef></SimpleTypeIdentifier>(<TupleExprElement>A: <IdentifierExpr><DeclNameRef>a</DeclNameRef></IdentifierExpr>, </TupleExprElement><TupleExprElement>B: <IdentifierExpr><DeclNameRef>b</DeclNameRef></IdentifierExpr>, </TupleExprElement><TupleExprElement>C:<IdentifierExpr><DeclNameRef>c</DeclNameRef></IdentifierExpr></TupleExprElement>)</CustomAttribute>
func foo<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{}</CodeBlock></FunctionDecl><StringLiteralExpr>

"<StringSegment>abc</StringSegment>"</StringLiteralExpr><StringLiteralExpr>
"<StringSegment>abc </StringSegment><ExpressionSegment>\(<TupleExprElement><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr></TupleExprElement>)</ExpressionSegment><StringSegment></StringSegment>"</StringLiteralExpr><StringLiteralExpr>
#"<StringSegment>abc</StringSegment>"#</StringLiteralExpr><StringLiteralExpr>
#"<StringSegment>abc </StringSegment><ExpressionSegment>\#(<TupleExprElement><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr></TupleExprElement>)</ExpressionSegment><StringSegment></StringSegment>"#</StringLiteralExpr><StringLiteralExpr>
##"<StringSegment>abc</StringSegment>"##</StringLiteralExpr><StringLiteralExpr>
##"<StringSegment>abc </StringSegment><ExpressionSegment>\##(<TupleExprElement><IdentifierExpr><DeclNameRef>foo</DeclNameRef></IdentifierExpr></TupleExprElement>)</ExpressionSegment><StringSegment></StringSegment>"##</StringLiteralExpr><PostfixIfConfigExpr><FunctionCallExpr><IdentifierExpr><DeclNameRef>

foo</DeclNameRef></IdentifierExpr>()</FunctionCallExpr><IfConfigDecl><IfConfigClause>
#if <IdentifierExpr><DeclNameRef>COND1</DeclNameRef></IdentifierExpr><ForcedValueExpr><FunctionCallExpr><OptionalChainingExpr><MemberAccessExpr>
  .<DeclNameRef>bar</DeclNameRef></MemberAccessExpr>?</OptionalChainingExpr>()</FunctionCallExpr>!</ForcedValueExpr></IfConfigClause><IfConfigClause>
#elseif <IdentifierExpr><DeclNameRef>COND2</DeclNameRef></IdentifierExpr><MemberAccessExpr><PostfixIfConfigExpr><IfConfigDecl><IfConfigClause>
  #if <BooleanLiteralExpr>true</BooleanLiteralExpr><FunctionCallExpr><MemberAccessExpr>
    .<DeclNameRef>call</DeclNameRef></MemberAccessExpr>()</FunctionCallExpr></IfConfigClause><IfConfigClause>
  #elseif <BooleanLiteralExpr>true</BooleanLiteralExpr><PostfixIfConfigExpr><IfConfigDecl><IfConfigClause>
    #if <BooleanLiteralExpr>true</BooleanLiteralExpr><MemberAccessExpr>
      .<DeclNameRef>other</DeclNameRef></MemberAccessExpr></IfConfigClause>
    #endif</IfConfigDecl></PostfixIfConfigExpr></IfConfigClause><IfConfigClause>
  #else<PostfixIfConfigExpr><FunctionCallExpr><MemberAccessExpr>
    .<DeclNameRef>before</DeclNameRef></MemberAccessExpr>()</FunctionCallExpr><IfConfigDecl><IfConfigClause>
    #if <BooleanLiteralExpr>true</BooleanLiteralExpr><FunctionCallExpr><MemberAccessExpr>
      .<DeclNameRef>after</DeclNameRef></MemberAccessExpr>()</FunctionCallExpr></IfConfigClause>
    #endif</IfConfigDecl></PostfixIfConfigExpr></IfConfigClause>
  #endif</IfConfigDecl></PostfixIfConfigExpr>
  .<DeclNameRef>member</DeclNameRef></MemberAccessExpr></IfConfigClause><IfConfigClause>
#else<FunctionCallExpr><MemberAccessExpr>
  .<DeclNameRef>baz</DeclNameRef></MemberAccessExpr>() <ClosureExpr>{}</ClosureExpr></FunctionCallExpr></IfConfigClause>
#endif</IfConfigDecl></PostfixIfConfigExpr>
